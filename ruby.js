// Generated by CoffeeScript 1.3.3

/*
RubyJS Alpha 0.7.2
Copyright (c) 2012 Sebastian Burkhard
All rights reserved.
http://www.rubyjs.org/LICENSE.txt
*/


(function() {
  var ArrayMethods, Block, BlockArgs, BlockMulti, BlockSingle, EnumerableMethods, MYSortedElement, NumericMethods, RArray, RCoerce, REnumerable, RString, StringMethods, error, errors, method, name, nativeArray, nativeNumber, nativeObject, nativeRegExp, nativeString, previousR, root, _arr, _arr_join_, _blockify, _enum, _fn, _i, _len, _num, _ref, _slice_, _str, _toString_,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.RubyJS = function(obj, recursive, block) {
    return RubyJS.Base.prototype.box(obj, recursive, block);
  };

  RubyJS.VERSION = '0.7.2';

  if (root.R != null) {
    previousR = root.R;
  }

  RubyJS.noConflict = function() {
    root.R = previousR;
    return RubyJS;
  };

  root.R = RubyJS;

  nativeArray = Array;

  nativeNumber = Number;

  nativeObject = Object;

  nativeRegExp = RegExp;

  nativeString = String;

  _toString_ = Object.prototype.toString;

  _slice_ = Array.prototype.slice;

  RubyJS.extend = function(obj, mixin) {
    var method, name;
    for (name in mixin) {
      method = mixin[name];
      obj[name] = method;
    }
    return obj;
  };

  RubyJS.include = function(mixin, replace) {
    var method, name, _ref;
    if (replace == null) {
      replace = false;
    }
    _ref = mixin.prototype;
    for (name in _ref) {
      method = _ref[name];
      if (replace) {
        this.prototype[name] = method;
      } else {
        if (!this.prototype[name]) {
          this.prototype[name] = method;
        }
      }
    }
    return mixin;
  };

  if (typeof exports !== 'undefined') {
    exports.R = R;
    exports.RubyJS = RubyJS;
  }

  Block = (function() {

    function Block() {}

    Block.create = function(block, thisArg) {
      if (block && (block.call != null)) {
        if (block.length !== 1) {
          return new BlockMulti(block, thisArg);
        } else {
          return new BlockSingle(block, thisArg);
        }
      } else {
        return new BlockArgs(block, thisArg);
      }
    };

    Block.supportMultipleArgs = function(block) {
      if (block.length === 1) {
        return block;
      } else {
        return function(item) {
          if (typeof item === 'object' && R.Array.isNativeArray(item)) {
            return block.apply(this, item);
          } else {
            return block(item);
          }
        };
      }
    };

    Block.prototype.invoke = function() {
      throw "Calling #invoke on an abstract Block instance";
    };

    Block.prototype.invokeSplat = function() {
      throw "Calling #invokeSplat on an abstract Block instance";
    };

    Block.prototype.args = function() {
      throw "Calling #args on an abstract Block instance";
    };

    return Block;

  })();

  BlockArgs = (function() {

    function BlockArgs(block, thisArg) {
      this.block = block;
      this.thisArg = thisArg;
    }

    BlockArgs.prototype.invoke = function(args) {
      return RCoerce.single_block_args(args, this.block);
    };

    return BlockArgs;

  })();

  BlockMulti = (function() {

    function BlockMulti(block, thisArg) {
      this.block = block;
      this.thisArg = thisArg;
    }

    BlockMulti.prototype.args = function(args) {
      if (args.length > 1) {
        return _slice_.call(args);
      } else {
        return args[0];
      }
    };

    BlockMulti.prototype.invoke = function(args) {
      var arg;
      if (args.length > 1) {
        return this.block.apply(this.thisArg, args);
      } else {
        arg = args[0];
        if (typeof arg === 'object' && R.Array.isNativeArray(arg)) {
          return this.block.apply(this.thisArg, arg);
        } else {
          return this.block.call(this.thisArg, arg);
        }
      }
    };

    BlockMulti.prototype.invokeSplat = function() {
      return this.block.apply(this.thisArg, arguments);
    };

    return BlockMulti;

  })();

  BlockSingle = (function() {

    function BlockSingle(block, thisArg) {
      this.block = block;
      this.thisArg = thisArg;
    }

    BlockSingle.prototype.args = function(args) {
      return args[0];
    };

    BlockSingle.prototype.invoke = function(args) {
      return this.block.call(this.thisArg, args[0]);
    };

    BlockSingle.prototype.invokeSplat = function() {
      return this.block.apply(this.thisArg, arguments);
    };

    return BlockSingle;

  })();

  R.Block = Block;

  R.blockify = _blockify = Block.create;

  RubyJS.Breaker = (function() {

    function Breaker(return_value, broken) {
      this.return_value = return_value != null ? return_value : null;
      this.broken = broken != null ? broken : false;
    }

    Breaker.prototype["break"] = function(return_value) {
      this.broken = true;
      this.return_value = return_value;
      throw this;
    };

    Breaker.prototype.handle_break = function(e) {
      if (this === e) {
        return e.return_value;
      } else {
        throw e;
      }
    };

    return Breaker;

  })();

  RubyJS.Kernel = (function() {

    function Kernel() {}

    Kernel.prototype.rubyjs = function() {
      return true;
    };

    Kernel.prototype.box = function(obj, recursive, block) {
      var object_type, _v;
      if (obj == null) {
        return obj;
      }
      if (typeof obj === 'object') {
        if (obj.rubyjs != null) {
          return obj;
        }
        _v = obj.valueOf();
        if (typeof _v !== 'object') {
          obj = _v;
        } else {
          if (R.Array.isNativeArray(obj)) {
            object_type = '[object Array]';
          } else {
            object_type = _toString_.call(obj);
          }
        }
      }
      if (typeof obj === 'number') {
        obj = RubyJS.Numeric.typecast(obj);
      } else if (typeof obj === 'string') {
        obj = new R.String(obj);
      } else if (object_type === '[object Array]') {
        obj = new R.Array(obj, recursive === true);
      } else if (object_type === '[object RegExp]') {
        obj = R.Regexp.try_convert(obj);
      }
      if (typeof recursive === 'function') {
        block = recursive;
        recursive = false;
      }
      if (typeof block === 'function') {
        obj = block.call(obj);
        if (obj === null || obj === void 0) {
          obj = null;
        } else if (obj.to_native != null) {
          obj = obj.to_native(true);
        }
      }
      return obj;
    };

    Kernel.prototype.w = function(str) {
      return R(str).split(/\s+/);
    };

    Kernel.prototype.r = function(a, b, excluding) {
      if (excluding === true) {
        return R.Range["new"](a, b, true);
      } else {
        return R.Range["new"](a, b);
      }
    };

    Kernel.prototype.f = function(flt) {
      return new R.Float(flt);
    };

    Kernel.prototype.rng = Kernel.prototype.r;

    Kernel.prototype.l = function(obj, recursive) {
      if (recursive == null) {
        recursive = false;
      }
      if (typeof obj === 'object') {
        if (obj.to_native != null) {
          return obj.to_native(true);
        } else {
          return obj;
        }
      } else {
        return obj;
      }
    };

    Kernel.prototype.catch_break = function(block, context) {
      var breaker;
      if (context == null) {
        context = this;
      }
      breaker = new R.Breaker();
      try {
        return block.call(context, breaker);
      } catch (e) {
        return breaker.handle_break(e);
      }
    };

    Kernel.prototype.$Array = function(obj, recursive) {
      var e;
      if (recursive == null) {
        recursive = false;
      }
      if (recursive === true) {
        return R.Array["new"]((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = obj.length; _i < _len; _i++) {
            e = obj[_i];
            _results.push(this.box(e));
          }
          return _results;
        }).call(this));
      } else {
        return R.Array["new"](obj);
      }
    };

    Kernel.prototype.$Array_r = function(obj) {
      return this.$Array(obj, true);
    };

    Kernel.prototype.$Float = function(obj) {
      var stripped;
      obj = this.box(obj);
      if (obj === null) {
        throw R.TypeError["new"]();
      }
      if (obj.to_f == null) {
        throw R.TypeError["new"]();
      }
      if (obj.is_float != null) {
        return obj;
      } else if (obj.is_string != null) {
        stripped = obj.strip();
        if (stripped.valid_float()) {
          return new R.Float(+stripped.to_native().replace(/_/g, ''));
        } else {
          throw R.ArgumentError["new"]();
        }
      } else if (obj.rubyjs != null) {
        return new R.Float(obj.to_native());
      } else {
        return new R.Float(obj);
      }
    };

    Kernel.prototype.$Integer = function(obj) {
      var stripped;
      obj = R(obj);
      if (obj == null) {
        throw R.TypeError["new"]();
      }
      if (obj.is_integer != null) {
        return obj;
      } else if (obj.is_string != null) {
        stripped = obj.strip();
        if (stripped.valid_float()) {
          return new R.Fixnum(Math.floor(+stripped.to_native().replace(/_/g, '')));
        } else {
          throw R.ArgumentError["new"]();
        }
      } else if (obj.rubyjs != null) {
        return new R.Fixnum(Math.floor(obj.to_native()));
      } else {
        return new R.Fixnum(Math.floor(obj));
      }
    };

    Kernel.prototype.$Integer = Kernel.prototype.$Integer;

    Kernel.prototype.$String = function(obj) {
      return R.String.try_convert(obj) || (function() {
        throw R.TypeError["new"]();
      })();
    };

    Kernel.prototype.$Range = function(start, end, exclusive) {
      return R.Range["new"](start, end, exclusive);
    };

    Kernel.prototype.puts = function(obj) {
      return console.log(obj);
    };

    Kernel.prototype.rand = function(limit) {
      var r;
      r = R(Math.random());
      if (limit) {
        return r.multiply(limit).to_i();
      } else {
        return r;
      }
    };

    Kernel.prototype.__ensure_args_length = function(args, length) {
      if (args.length !== length) {
        throw R.ArgumentError["new"]();
      }
    };

    Kernel.prototype.__ensure_numeric = function(obj) {
      if ((obj != null ? obj.is_numeric : void 0) == null) {
        throw R.TypeError["new"]();
      }
    };

    Kernel.prototype.__ensure_string = function(obj) {
      if ((obj != null ? obj.is_string : void 0) == null) {
        throw R.TypeError["new"]();
      }
    };

    Kernel.prototype.__extract_block = function(args) {
      var idx, _ref;
      idx = args.length;
      while (--idx >= 0) {
        if (((_ref = args[idx]) != null ? _ref.call : void 0) != null) {
          return args.pop();
        }
      }
      return null;
    };

    return Kernel;

  })();

  RubyJS.Base = (function() {

    function Base() {}

    RubyJS.include.call(Base, R.Kernel);

    Base.prototype['$~'] = null;

    Base.prototype['$,'] = null;

    Base.prototype['$;'] = "\n";

    Base.prototype['$/'] = "\n";

    Base.prototype.inspect = function(obj) {
      if (obj === null || obj === 'undefined') {
        return 'null';
      } else if (obj.inspect != null) {
        return obj.inspect();
      } else if (R.Array.isNativeArray(obj)) {
        return "[" + obj + "]";
      } else {
        return obj;
      }
    };

    Base.prototype.pollute_global = function(prefix) {
      var args, method, name, _i, _len;
      if (prefix == null) {
        prefix = "_";
      }
      if (arguments.length === 0) {
        args = ['fn', '_str', '_arr', '_enum', '_num', 'proc', 'puts', 'truthy', 'falsey', 'inspect'];
      } else {
        args = arguments;
      }
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        method = args[_i];
        name = prefix + method.replace(/_/, '');
        if (root[name] != null) {
          R.puts("RubyJS.pollute_global(): " + name + " already exists.");
        } else {
          root[name] = this[method];
        }
      }
      return null;
    };

    Base.prototype.pollute_more = function() {
      var shortcuts;
      return shortcuts = {
        _arr: '_a',
        _num: '_n',
        _str: '_s',
        _enum: '_e',
        _hsh: '_h'
      };
    };

    Base.prototype.i_am_feeling_evil = function() {
      var func, methods, name, overwrites, proto, _i, _len, _ref;
      overwrites = [[Array.prototype, _arr], [Number.prototype, _num], [String.prototype, _str]];
      for (_i = 0, _len = overwrites.length; _i < _len; _i++) {
        _ref = overwrites[_i], proto = _ref[0], methods = _ref[1];
        for (name in methods) {
          func = methods[name];
          if (typeof func === 'function') {
            if (proto[name] != null) {
              console.log("" + proto + "." + name + " exists. Method prefixed with 'rb_'");
              name = "rb_" + name;
            }
            (function(name, methods) {
              return proto[name] = function() {
                var args;
                args = [this.valueOf()].concat(_slice_.call(arguments, 0));
                return methods[name].apply(methods, args);
              };
            })(name, methods);
          }
        }
      }
      return "harr harr";
    };

    Base.prototype.proc = function() {
      var args, key;
      key = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (args.length === 0) {
        return function(el) {
          return el[key]();
        };
      } else {
        return function(el) {
          return el[key].apply(el, args);
        };
      }
    };

    Base.prototype.fn = function() {
      var args, func;
      func = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return function(el) {
        return func.apply(null, [el].concat(args));
      };
    };

    Base.prototype.falsey = function(obj) {
      return obj === false || obj === null || obj === void 0;
    };

    Base.prototype.truthy = function(obj) {
      return !this.falsey(obj);
    };

    Base.prototype.unbox = function(obj, recursive) {
      if (recursive == null) {
        recursive = false;
      }
      return obj.unbox(recursive);
    };

    Base.prototype.respond_to = function(obj, function_name) {
      return obj[function_name] !== void 0;
    };

    Base.prototype.is_equal = function(a, b) {
      if (typeof a === 'object') {
        if (a.equals != null) {
          return a.equals(b);
        } else if (a['=='] != null) {
          return a['=='](b);
        } else {
          return a === b;
        }
      } else if (typeof b === 'object') {
        if (b.equals != null) {
          return b.equals(a);
        } else if (b['=='] != null) {
          return b['=='](a);
        } else {
          return a === b;
        }
      } else {
        return a === b;
      }
    };

    Base.prototype.is_eql = function(a, b) {
      if (typeof a === 'object') {
        return a.eql(b);
      } else if (typeof b === 'object') {
        return b.eql(a);
      } else {
        return a === b;
      }
    };

    Base.prototype.extend = function(obj, mixin) {
      var method, name;
      for (name in mixin) {
        method = mixin[name];
        obj[name] = method;
      }
      return obj;
    };

    return Base;

  })();

  _ref = RubyJS.Base.prototype;
  for (name in _ref) {
    if (!__hasProp.call(_ref, name)) continue;
    method = _ref[name];
    RubyJS[name] = method;
  }

  RCoerce = R._coerce = {
    single_block_args: function(args, block) {
      if (block) {
        if (block.length !== 1) {
          if (args.length > 1) {
            return _slice_.call(args);
          } else {
            return args[0];
          }
        } else {
          return args[0];
        }
      } else {
        if (args.length !== 1) {
          return _slice_.call(args);
        } else {
          return args[0];
        }
      }
    },
    coerce: function(obj, to_what, skip_native) {
      if (skip_native !== void 0 && skip_native === typeof obj) {
        return obj;
      } else {
        if (obj === null || obj === void 0) {
          throw new R.TypeError["new"]();
        }
        obj = R(obj);
        if (obj[to_what] == null) {
          throw R.TypeError["new"]("TypeError: cant't convert ... into String");
        }
        if (skip_native !== void 0) {
          return obj[to_what]().to_native();
        } else {
          return obj[to_what]();
        }
      }
    },
    to_native: function(obj) {
      return typeof obj.to_native === "function" ? obj.to_native() : void 0;
    },
    to_num_native: function(obj) {
      if (typeof obj === 'number') {
        return obj;
      } else {
        obj = R(obj);
        if (!(obj.is_numeric != null)) {
          throw R.TypeError["new"]();
        }
        return obj.to_native();
      }
    },
    to_int: function(obj) {
      return RCoerce.coerce(obj, 'to_int');
    },
    to_int_native: function(obj) {
      if (typeof obj === 'number' && (obj % 1 === 0)) {
        return obj;
      } else {
        return RCoerce.coerce(obj, 'to_int').to_native();
      }
    },
    to_str: function(obj) {
      return RCoerce.coerce(obj, 'to_str');
    },
    to_str_native: function(obj) {
      return RCoerce.coerce(obj, 'to_str', 'string');
    },
    to_ary: function(obj) {
      return this.coerce(obj, 'to_ary');
    },
    to_ary_native: function(obj) {
      if (RArray.isNativeArray(obj)) {
        return obj;
      } else {
        return RCoerce.coerce(obj, 'to_ary').to_native();
      }
    }
  };

  R.RCoerce = RCoerce;

  RubyJS.Object = (function() {

    function Object() {}

    Object.include = RubyJS.include;

    Object.__add_default_aliases__ = function(proto) {
      if (proto['<<'] != null) {
        proto.append = proto['<<'];
      }
      if (proto['=='] != null) {
        proto.equals = proto['=='];
      }
      if (proto['==='] != null) {
        proto.equal_case = proto['==='];
      }
      if (proto['<=>'] != null) {
        proto.cmp = proto['<=>'];
      }
      if (proto['%'] != null) {
        proto.modulo = proto['%'];
      }
      if (proto['+'] != null) {
        proto.plus = proto['+'];
      }
      if (proto['-'] != null) {
        proto.minus = proto['-'];
      }
      if (proto['*'] != null) {
        proto.multiply = proto['*'];
      }
      if (proto['**'] != null) {
        proto.exp = proto['**'];
      }
      if (proto['/'] != null) {
        proto.divide = proto['/'];
      }
      if (proto.equal_case != null) {
        proto.equalCase = proto.equal_case;
      }
      if (proto.equal_value != null) {
        proto.equalValue = proto.equal_value;
      }
      if (proto.to_a != null) {
        proto.toA = proto.to_a;
      }
      if (proto.to_f != null) {
        proto.toF = proto.to_f;
      }
      if (proto.to_i != null) {
        proto.toI = proto.to_i;
      }
      if (proto.to_int != null) {
        proto.toInt = proto.to_int;
      }
      if (proto.to_s != null) {
        proto.toS = proto.to_s;
      }
      if (proto.to_str != null) {
        proto.toStr = proto.to_str;
      }
      if (proto.to_enum != null) {
        proto.toEnum = proto.to_enum;
      }
      if (proto.to_native != null) {
        return proto.toNative = proto.to_native;
      }
    };

    Object.include(RubyJS.Kernel);

    Object.prototype.send = function() {
      var args, method_name;
      method_name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return this[method_name](args);
    };

    Object.prototype.respond_to = function(method_name) {
      return this[method_name] != null;
    };

    Object.prototype.to_enum = function() {
      var args, iter;
      iter = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (iter == null) {
        iter = "each";
      }
      return new RubyJS.Enumerator(this, iter, args);
    };

    Object.prototype.tap = function(block) {
      block(this);
      return this;
    };

    Object.prototype.value = function() {
      return this.to_native.apply(this, arguments);
    };

    return Object;

  })();

  NumericMethods = (function() {

    function NumericMethods() {}

    NumericMethods.prototype.cmp = function(num, other) {
      if (num === other) {
        return 0;
      } else {
        return null;
      }
    };

    NumericMethods.prototype.abs = function(num) {
      if (num < 0) {
        return -num;
      } else {
        return num;
      }
    };

    NumericMethods.prototype.abs2 = function(num) {
      if (this.nan(num)) {
        return num;
      }
      return Math.pow(num, 2);
    };

    NumericMethods.prototype.ceil = function(num) {
      return Math.ceil(num);
    };

    NumericMethods.prototype.divmod = function(num, other) {
      var modulus, quotient;
      quotient = Math.floor(num / other);
      modulus = num % other;
      return [quotient, modulus];
    };

    NumericMethods.prototype.downto = function(num, stop, block) {
      stop = Math.ceil(stop);
      while (num >= stop) {
        block(num);
        num -= 1;
      }
      return num;
    };

    NumericMethods.prototype.eql = function(num, other) {
      return num === other;
    };

    NumericMethods.prototype.floor = function(num) {
      return Math.floor(num);
    };

    NumericMethods.prototype.nonzero = function(num) {
      if (num === 0) {
        return null;
      } else {
        return num;
      }
    };

    NumericMethods.prototype.step = function(num, limit, step, block) {
      var d, float_mode, i, n;
      if (step == null) {
        step = 1;
      }
      if ((block != null ? block.call : void 0) == null) {
        block = step;
        step = 1;
      }
      if (step === 0) {
        throw new R.ArgumentError("ArgumentError");
      }
      float_mode = num % 1 === 0 || limit % 1 === 0 || step % 1 === 0;
      if (float_mode) {
        n = (limit - num) / step;
        i = 0;
        if (step > 0) {
          while (i <= n) {
            d = i * step + num;
            if (limit < d) {
              d = limit;
            }
            block(d);
            i += 1;
          }
        } else {
          while (i <= n) {
            d = i * step + num;
            if (limit > d) {
              d = limit;
            }
            block(d);
            i += 1;
          }
        }
      } else {
        if (step > 0) {
          while (!(num > limit)) {
            block(num);
            num += step;
          }
        } else {
          while (!(num < limit)) {
            block(num);
            num += step;
          }
        }
      }
      return this;
    };

    NumericMethods.prototype.upto = function(num, stop, block) {
      stop = Math.floor(stop);
      while (num <= stop) {
        block(num);
        num += 1;
      }
      return num;
    };

    NumericMethods.prototype.zero = function(num) {
      return num === 0;
    };

    NumericMethods.prototype.even = function(num) {
      return num % 2 === 0;
    };

    NumericMethods.prototype.gcd = function(num, other) {
      var t;
      t = null;
      while (other !== 0) {
        t = other;
        other = num % other;
        num = t;
      }
      if (num < 0) {
        return -num;
      } else {
        return num;
      }
    };

    NumericMethods.prototype.gcdlcm = function(other) {
      other = this.box(other);
      this.__ensure_args_length(arguments, 1);
      this.__ensure_integer__(other);
      return new R.Array([this.gcd(other), this.lcm(other)]);
    };

    NumericMethods.prototype.lcm = function(other) {
      var lcm;
      other = R(other);
      this.__ensure_args_length(arguments, 1);
      this.__ensure_integer__(other);
      lcm = new R.Fixnum(this.to_native() * other.to_native() / this.gcd(other));
      return lcm.numerator();
    };

    NumericMethods.prototype.numerator = function(num) {
      if (num < 0) {
        return -num;
      } else {
        return num;
      }
    };

    NumericMethods.prototype.odd = function(num) {
      return num % 2 === 1;
    };

    NumericMethods.prototype.ord = function() {
      return this;
    };

    NumericMethods.prototype.next = function(num) {
      return num + 1;
    };

    NumericMethods.prototype.pred = function(num) {
      return num - 1;
    };

    NumericMethods.prototype.round = function(num, n) {
      var multiplier;
      if (n === void 0) {
        return num;
      }
      multiplier = Math.pow(10, n);
      return Math.round(num * multiplier) / multiplier;
    };

    NumericMethods.prototype.times = function(num, block) {
      var idx;
      if (num > 0) {
        idx = 0;
        while (idx < num) {
          block(idx);
          idx = idx + 1;
        }
        return num;
      } else {
        return num;
      }
    };

    NumericMethods.prototype.magnitude = NumericMethods.prototype.abs;

    NumericMethods.prototype.succ = NumericMethods.prototype.next;

    return NumericMethods;

  })();

  _num = R._num = new NumericMethods();

  EnumerableMethods = (function() {

    function EnumerableMethods() {}

    EnumerableMethods.prototype.catch_break = R.Kernel.prototype.catch_break;

    EnumerableMethods.prototype.each = function(coll, block) {
      var k, v;
      if (coll.each != null) {
        coll.each(block);
      } else if (RArray.isNativeArray(coll)) {
        _arr.each(coll, block);
      } else {
        for (k in coll) {
          if (!__hasProp.call(coll, k)) continue;
          v = coll[k];
          block(k, v);
        }
      }
      return coll;
    };

    EnumerableMethods.prototype.all = function(coll, block) {
      return this.catch_break(function(breaker) {
        var callback;
        callback = _blockify(block, coll);
        this.each(coll, function() {
          var result;
          result = callback.invoke(arguments);
          if (R.falsey(result)) {
            return breaker["break"](false);
          }
        });
        return true;
      });
    };

    EnumerableMethods.prototype.any = function(coll, block) {
      return this.catch_break(function(breaker) {
        var callback;
        callback = _blockify(block, coll);
        this.each(coll, function() {
          var result;
          result = callback.invoke(arguments);
          if (!R.falsey(result)) {
            return breaker["break"](true);
          }
        });
        return false;
      });
    };

    EnumerableMethods.prototype.collect_concat = function(coll, block) {
      var ary, callback;
      if (block == null) {
        block = null;
      }
      callback = _blockify(block, this);
      ary = [];
      this.each(coll, function() {
        return ary.push(callback.invoke(arguments));
      });
      return _arr.flatten(ary, 1);
    };

    EnumerableMethods.prototype.flat_map = EnumerableMethods.collect_concat;

    EnumerableMethods.prototype.count = function(coll, block) {
      var callback, countable, counter;
      counter = 0;
      if (block === void 0) {
        this.each(coll, function() {
          return counter += 1;
        });
      } else if (block === null) {
        this.each(coll, function(el) {
          if (el === null) {
            return counter += 1;
          }
        });
      } else if (block.call != null) {
        callback = _blockify(block, coll);
        this.each(coll, function() {
          var result;
          result = callback.invoke(arguments);
          if (!R.falsey(result)) {
            return counter += 1;
          }
        });
      } else {
        countable = R(block);
        this.each(coll, function(el) {
          if (countable['=='](el)) {
            return counter += 1;
          }
        });
      }
      return counter;
    };

    EnumerableMethods.prototype.cycle = function(coll, n, block) {
      var cache, callback, i, many, _results, _results1;
      if (!block) {
        if (n && (n.call != null)) {
          block = n;
          n = null;
        }
      }
      if (!(n === null || n === void 0)) {
        many = RCoerce.to_int_native(n);
        if (many <= 0) {
          return null;
        }
      } else {
        many = null;
      }
      if (!block) {
        return coll.to_enum('cycle', n);
      }
      callback = _blockify(block, coll);
      cache = new R.Array([]);
      this.each(coll, function() {
        var args;
        args = callback.args(arguments);
        cache.append(args);
        return callback.invoke(arguments);
      });
      if (cache.empty()) {
        return null;
      }
      if (many > 0) {
        i = 0;
        many -= 1;
        _results = [];
        while (many > i) {
          _results.push(cache.each(function() {
            callback.invoke(arguments);
            return i += 1;
          }));
        }
        return _results;
      } else {
        _results1 = [];
        while (true) {
          _results1.push(cache.each(function() {
            return callback.invoke(arguments);
          }));
        }
        return _results1;
      }
    };

    EnumerableMethods.prototype.drop = function(coll, n) {
      var ary;
      ary = [];
      this.each_with_index(coll, function(el, idx) {
        if (n <= idx) {
          return ary.push(el);
        }
      });
      return ary;
    };

    EnumerableMethods.prototype.drop_while = function(coll, block) {
      var ary, callback, dropping;
      callback = _blockify(block, coll);
      ary = [];
      dropping = true;
      this.each(coll, function() {
        if (!(dropping && callback.invoke(arguments))) {
          dropping = false;
          return ary.push(callback.args(arguments));
        }
      });
      return ary;
    };

    EnumerableMethods.prototype.each_cons = function(coll, n, block) {
      var ary, callback, len;
      callback = _blockify(block, coll);
      len = block.length;
      ary = [];
      this.each(coll, function() {
        ary.push(BlockMulti.prototype.args(arguments));
        if (ary.length > n) {
          ary.shift();
        }
        if (ary.length === n) {
          if (len > 1) {
            return block.apply(coll, ary.slice(0));
          } else {
            return block.call(coll, ary.slice(0));
          }
        }
      });
      return null;
    };

    EnumerableMethods.prototype.each_entry = function(coll, block) {
      var callback, len;
      callback = new BlockMulti(block, coll);
      len = block.length;
      this.each(coll, function() {
        var args;
        args = callback.args(arguments);
        if (len > 1 && R.Array.isNativeArray(args)) {
          return block.apply(coll, args);
        } else {
          return block.call(coll, args);
        }
      });
      return coll;
    };

    EnumerableMethods.prototype.each_slice = function(coll, n, block) {
      var args, ary, callback, len;
      callback = _blockify(block, coll);
      len = block.length;
      ary = [];
      this.each(coll, function() {
        var args;
        ary.push(BlockMulti.prototype.args(arguments));
        if (ary.length === n) {
          args = ary.slice(0);
          if (len > 1) {
            block.apply(coll, args);
          } else {
            block.call(coll, args);
          }
          return ary = [];
        }
      });
      if (ary.length !== 0) {
        args = ary.slice(0);
        if (len > 1) {
          block.apply(coll, args);
        } else {
          block.call(coll, args);
        }
      }
      return null;
    };

    EnumerableMethods.prototype.each_with_index = function(coll, block) {
      var callback, idx;
      callback = _blockify(block, coll);
      idx = 0;
      this.each(coll, function() {
        var val;
        val = callback.invokeSplat(callback.args(arguments), idx);
        idx += 1;
        return val;
      });
      return coll;
    };

    EnumerableMethods.prototype.each_with_object = function(coll, obj, block) {
      var callback;
      callback = _blockify(block, coll);
      this.each(coll, function() {
        var args;
        args = BlockMulti.prototype.args(arguments);
        return callback.invokeSplat(args, obj);
      });
      return obj;
    };

    EnumerableMethods.prototype.find = function(coll, ifnone, block) {
      var callback;
      if (block == null) {
        block = null;
      }
      if (block === null) {
        block = ifnone;
        ifnone = null;
      }
      callback = _blockify(block, this);
      return this.catch_break(function(breaker) {
        this.each(coll, function() {
          if (!R.falsey(callback.invoke(arguments))) {
            return breaker["break"](callback.args(arguments));
          }
        });
        return typeof ifnone === "function" ? ifnone() : void 0;
      });
    };

    EnumerableMethods.prototype.find_all = function(coll, block) {
      var ary, callback;
      ary = [];
      callback = _blockify(block, coll);
      this.each(coll, function() {
        if (!R.falsey(callback.invoke(arguments))) {
          return ary.push(callback.args(arguments));
        }
      });
      return ary;
    };

    EnumerableMethods.prototype.find_index = function(coll, value) {
      var block, callback, idx;
      if (value.call != null) {
        block = value;
      } else {
        block = function(el) {
          return R.is_equal(value, el);
        };
      }
      idx = 0;
      callback = _blockify(block, coll);
      return this.catch_break(function(breaker) {
        this.each(coll, function() {
          if (callback.invoke(arguments)) {
            breaker["break"](idx);
          }
          return idx += 1;
        });
        return null;
      });
    };

    EnumerableMethods.prototype.first = function(coll, n) {
      if (n == null) {
        n = null;
      }
      if (n !== null) {
        if (n < 0) {
          throw new R.ArgumentError('ArgumentError');
        }
        return this.take(coll, n);
      } else {
        return this.take(coll, 1)[0];
      }
    };

    EnumerableMethods.prototype.include = function(coll, other) {
      other = R(other);
      return this.catch_break(function(breaker) {
        this.each(coll, function(el) {
          el = R(el);
          if ((typeof el['=='] === "function" ? el['=='](other) : void 0) || (typeof other['=='] === "function" ? other['=='](el) : void 0) || el === other) {
            return breaker["break"](true);
          }
        });
        return false;
      });
    };

    EnumerableMethods.prototype.__inject_args__ = function(initial, sym, block) {
      var _method, _ref1;
      if ((sym != null ? sym.call : void 0) != null) {
        block = sym;
      } else if (sym) {
        block = function(memo, el) {
          return memo[sym](el);
        };
      } else if (((_ref1 = R(initial)) != null ? _ref1.is_string : void 0) != null) {
        _method = "" + initial;
        block = function(memo, el) {
          return memo[_method](el);
        };
        initial = void 0;
      } else if (initial.call != null) {
        block = initial;
        initial = void 0;
      }
      return [initial, sym, block];
    };

    EnumerableMethods.prototype.inject = function(coll, init, sym, block) {
      var callback, _ref1;
      _ref1 = this.__inject_args__(init, sym, block), init = _ref1[0], sym = _ref1[1], block = _ref1[2];
      callback = R.blockify(block, coll);
      this.each(coll, function() {
        var args;
        if (init === void 0) {
          return init = callback.args(arguments);
        } else {
          args = BlockMulti.prototype.args(arguments);
          return init = callback.invokeSplat(init, args);
        }
      });
      return init;
    };

    EnumerableMethods.prototype.grep = function(coll, pattern, block) {
      var ary, callback;
      ary = [];
      pattern = R(pattern);
      callback = R.blockify(block, coll);
      if (block) {
        this.each(coll, function(el) {
          if (pattern['==='](el)) {
            return ary.push(callback.invoke(arguments));
          }
        });
      } else {
        this.each(coll, function(el) {
          if (pattern['==='](el)) {
            return ary.push(el);
          }
        });
      }
      return ary;
    };

    EnumerableMethods.prototype.group_by = function(coll, block) {
      var callback, h;
      callback = R.blockify(block, coll);
      h = {};
      this.each(coll, function() {
        var args, key;
        args = callback.args(arguments);
        key = callback.invoke(arguments);
        h[key] || (h[key] = []);
        return h[key].push(args);
      });
      return h;
    };

    EnumerableMethods.prototype.map = function(coll, block) {
      var arr, callback;
      callback = R.blockify(block, coll);
      arr = [];
      this.each(coll, function() {
        return arr.push(callback.invoke(arguments));
      });
      return arr;
    };

    EnumerableMethods.prototype.max = function(coll, block) {
      var max;
      max = void 0;
      block || (block = R.Comparable.cmp);
      this.each(coll, function(item) {
        var comp;
        if (max === void 0) {
          return max = item;
        } else {
          comp = block(item, max);
          if (comp === null) {
            throw R.ArgumentError["new"]();
          }
          if (comp > 0) {
            return max = item;
          }
        }
      });
      return max || null;
    };

    EnumerableMethods.prototype.max_by = function(coll, block) {
      var max;
      max = void 0;
      this.each(coll, function(item) {
        var cmp;
        if (max === void 0) {
          return max = item;
        } else {
          cmp = R.Comparable.cmpstrict(block(item), block(max));
          if (cmp > 0) {
            return max = item;
          }
        }
      });
      return max || null;
    };

    EnumerableMethods.prototype.min = function(coll, block) {
      var min;
      min = void 0;
      block || (block = R.Comparable.cmp);
      this.each(coll, function(item) {
        var comp;
        if (min === void 0) {
          return min = item;
        } else {
          comp = block.call(this, item, min);
          if (comp === null) {
            throw R.ArgumentError["new"]();
          }
          if (comp < 0) {
            return min = item;
          }
        }
      });
      return min || null;
    };

    EnumerableMethods.prototype.min_by = function(coll, block) {
      var min;
      min = void 0;
      this.each(coll, function(item) {
        var cmp;
        if (min === void 0) {
          return min = item;
        } else {
          cmp = R.Comparable.cmpstrict(block(item), block(min));
          if (cmp < 0) {
            return min = item;
          }
        }
      });
      return min || null;
    };

    EnumerableMethods.prototype.minmax = function(coll, block) {
      return [this.min(coll, block), this.max(coll, block)];
    };

    EnumerableMethods.prototype.minmax_by = function(coll, block) {
      return [this.min_by(coll, block), this.max_by(coll, block)];
    };

    EnumerableMethods.prototype.none = function(coll, block) {
      return this.catch_break(function(breaker) {
        var callback;
        callback = R.blockify(block, coll);
        this.each(coll, function(args) {
          var result;
          result = callback.invoke(arguments);
          if (!R.falsey(result)) {
            return breaker["break"](false);
          }
        });
        return true;
      });
    };

    EnumerableMethods.prototype.one = function(coll, block) {
      var counter;
      counter = 0;
      return this.catch_break(function(breaker) {
        var callback;
        callback = R.blockify(block, coll);
        this.each(coll, function(args) {
          var result;
          result = callback.invoke(arguments);
          if (!R.falsey(result)) {
            counter += 1;
          }
          if (counter > 1) {
            return breaker["break"](false);
          }
        });
        return counter === 1;
      });
    };

    EnumerableMethods.prototype.partition = function(coll, block) {
      var callback, left, right;
      left = [];
      right = [];
      callback = R.blockify(block, coll);
      this.each(coll, function() {
        var args;
        args = BlockMulti.prototype.args(arguments);
        if (callback.invokeSplat(args)) {
          return left.push(args);
        } else {
          return right.push(args);
        }
      });
      return [left, right];
    };

    EnumerableMethods.prototype.reject = function(coll, block) {
      var ary, callback;
      callback = R.blockify(block, coll);
      ary = [];
      this.each(coll, function() {
        if (R.falsey(callback.invoke(arguments))) {
          return ary.push(callback.args(arguments));
        }
      });
      return ary;
    };

    EnumerableMethods.prototype.reverse_each = function(coll, block) {
      _arr.reverse_each(this.to_a(coll), block);
      return coll;
    };

    EnumerableMethods.prototype.slice_before = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    };

    EnumerableMethods.prototype.sort = function(coll, block) {
      block || (block = R.Comparable.cmpstrict);
      if (coll.to_native != null) {
        coll = coll.to_native();
      }
      return coll.sort(block);
    };

    EnumerableMethods.prototype.sort_by = function(coll, block) {
      var ary, callback;
      callback = R.blockify(block, coll);
      ary = [];
      this.each(coll, function(value) {
        return ary.push(new MYSortedElement(value, callback.invoke(arguments)));
      });
      ary = _arr.sort(ary, R.Comparable.cmpstrict);
      return _arr.map(ary, function(se) {
        return se.value;
      });
    };

    EnumerableMethods.prototype.take = function(coll, n) {
      var ary;
      if (n < 0) {
        throw R.ArgumentError["new"]();
      }
      ary = [];
      this.catch_break(function(breaker) {
        return this.each(coll, function() {
          if (ary.length === n) {
            breaker["break"]();
          }
          return ary.push(BlockMulti.prototype.args(arguments));
        });
      });
      return ary;
    };

    EnumerableMethods.prototype.take_while = function(coll, block) {
      var ary;
      ary = [];
      this.catch_break(function(breaker) {
        return this.each(coll, function() {
          if (R.falsey(block.apply(coll, arguments))) {
            breaker["break"]();
          }
          return ary.push(BlockMulti.prototype.args(arguments));
        });
      });
      return ary;
    };

    EnumerableMethods.prototype.to_a = function(coll) {
      var ary;
      ary = [];
      this.each(coll, function() {
        ary.push(BlockMulti.prototype.args(arguments));
        return null;
      });
      return ary;
    };

    EnumerableMethods.prototype.to_enum = function() {
      var args, iter;
      iter = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (iter == null) {
        iter = "each";
      }
      return new R.Enumerator(this, iter, args);
    };

    EnumerableMethods.prototype.zip = function(coll, others) {};

    EnumerableMethods.prototype.detect = EnumerableMethods.prototype.find;

    EnumerableMethods.prototype.select = EnumerableMethods.prototype.find_all;

    EnumerableMethods.prototype.collectConcat = EnumerableMethods.prototype.collect_concat;

    EnumerableMethods.prototype.dropWhile = EnumerableMethods.prototype.drop_while;

    EnumerableMethods.prototype.eachCons = EnumerableMethods.prototype.each_cons;

    EnumerableMethods.prototype.eachEntry = EnumerableMethods.prototype.each_entry;

    EnumerableMethods.prototype.eachSlice = EnumerableMethods.prototype.each_slice;

    EnumerableMethods.prototype.eachWithIndex = EnumerableMethods.prototype.each_with_index;

    EnumerableMethods.prototype.eachWithObject = EnumerableMethods.prototype.each_with_object;

    EnumerableMethods.prototype.findAll = EnumerableMethods.prototype.find_all;

    EnumerableMethods.prototype.findIndex = EnumerableMethods.prototype.find_index;

    EnumerableMethods.prototype.flatMap = EnumerableMethods.prototype.flat_map;

    EnumerableMethods.prototype.groupBy = EnumerableMethods.prototype.group_by;

    EnumerableMethods.prototype.maxBy = EnumerableMethods.prototype.max_by;

    EnumerableMethods.prototype.minBy = EnumerableMethods.prototype.min_by;

    EnumerableMethods.prototype.minmaxBy = EnumerableMethods.prototype.minmax_by;

    EnumerableMethods.prototype.reverseEach = EnumerableMethods.prototype.reverse_each;

    EnumerableMethods.prototype.sliceBefore = EnumerableMethods.prototype.slice_before;

    EnumerableMethods.prototype.sortBy = EnumerableMethods.prototype.sort_by;

    EnumerableMethods.prototype.takeWhile = EnumerableMethods.prototype.take_while;

    EnumerableMethods.prototype.toA = EnumerableMethods.prototype.to_a;

    EnumerableMethods.prototype.collect = EnumerableMethods.prototype.map;

    EnumerableMethods.prototype.member = EnumerableMethods.prototype.include;

    EnumerableMethods.prototype.reduce = EnumerableMethods.prototype.inject;

    EnumerableMethods.prototype.entries = EnumerableMethods.prototype.to_a;

    return EnumerableMethods;

  })();

  MYSortedElement = (function() {

    function MYSortedElement(value, sort_by) {
      this.value = value;
      this.sort_by = sort_by;
    }

    MYSortedElement.prototype['<=>'] = function(other) {
      var _ref1;
      return (_ref1 = this.sort_by) != null ? _ref1['<=>'](other.sort_by) : void 0;
    };

    return MYSortedElement;

  })();

  _enum = R._enum = new EnumerableMethods();

  _arr_join_ = Array.prototype.join;

  ArrayMethods = (function(_super) {

    __extends(ArrayMethods, _super);

    function ArrayMethods() {
      return ArrayMethods.__super__.constructor.apply(this, arguments);
    }

    ArrayMethods.prototype.equals = function(arr, other) {
      var i, total;
      if (arr === other) {
        return true;
      }
      if (other == null) {
        return false;
      }
      if (!RArray.isNativeArray(other)) {
        if (other.to_ary == null) {
          return false;
        }
      }
      if (arr.length !== other.length) {
        return false;
      }
      i = 0;
      total = i + arr.length;
      while (i < total) {
        if (!R.is_equal(arr[i], other[i])) {
          return false;
        }
        i += 1;
      }
      return true;
    };

    ArrayMethods.prototype.append = function(arr, obj) {
      arr.push(obj);
      return arr;
    };

    ArrayMethods.prototype['&'] = function(other) {
      var arr;
      other = RCoerce.to_ary(other);
      arr = new R.Array([]);
      this.each(function(el) {
        if (other.include(el)) {
          return arr.push(el);
        }
      });
      return arr.uniq();
    };

    ArrayMethods.prototype['<=>'] = function(other) {};

    ArrayMethods.prototype.at = function(arr, index) {
      if (index < 0) {
        return arr[arr.length + index];
      } else {
        return arr[index];
      }
    };

    ArrayMethods.prototype.combination = function(arr, num, block) {
      var chosen, done, i, len, lev, stack;
      len = arr.length;
      if (num === 0) {
        block([]);
      } else if (num === 1) {
        this.each(arr, function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return block.call(arr, args);
        });
      } else if (num === len) {
        block(arr.slice(0));
      } else if (num >= 0 && num < len) {
        num = num;
        stack = (function() {
          var _i, _ref1, _results;
          _results = [];
          for (i = _i = 0, _ref1 = num + 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
            _results.push(0);
          }
          return _results;
        })();
        chosen = [];
        lev = 0;
        done = false;
        stack[0] = -1;
        while (!done) {
          chosen[lev] = arr[stack[lev + 1]];
          while (lev < num - 1) {
            lev += 1;
            stack[lev + 1] = stack[lev] + 1;
            chosen[lev] = arr[stack[lev + 1]];
          }
          block.call(arr, chosen.slice(0));
          lev += 1;
          done = lev === 0;
          stack[lev] += 1;
          lev = lev - 1;
          while (stack[lev + 1] + num === len + lev + 1) {
            done = lev === 0;
            stack[lev] += 1;
            lev = lev - 1;
          }
        }
      }
      return arr;
    };

    ArrayMethods.prototype.compact = function(arr) {
      var ary;
      ary = [];
      this.each(arr, function(el) {
        if (el != null) {
          return ary.push(el);
        }
      });
      return ary;
    };

    ArrayMethods.prototype["delete"] = function(arr, obj, block) {
      var deleted, i, len, _i, _len, _ref1;
      deleted = [];
      i = 0;
      len = arr.length;
      while (i < len) {
        if (R.is_equal(obj, arr[i])) {
          deleted.push(i);
        }
        i += 1;
      }
      if (deleted.length > 0) {
        _ref1 = deleted.reverse();
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          i = _ref1[_i];
          arr.splice(i, 1);
        }
        return obj;
      }
      if (block) {
        return block();
      } else {
        return null;
      }
    };

    ArrayMethods.prototype.delete_at = function(arr, idx) {
      if (idx < 0) {
        idx = idx + arr.length;
      }
      if (idx < 0 || idx >= arr.length) {
        return null;
      }
      return arr.splice(idx, 1)[0];
    };

    ArrayMethods.prototype.flatten = function(coll, recursion) {
      var arr;
      if (recursion == null) {
        recursion = -1;
      }
      recursion = RCoerce.to_int_native(recursion);
      arr = [];
      this.each(coll, function(element) {
        var el;
        el = R(element);
        if (recursion !== 0 && ((el != null ? el.to_ary : void 0) != null)) {
          return el.to_ary().flatten(recursion - 1).each(function(e) {
            return arr.push(e);
          });
        } else {
          return arr.push(element);
        }
      });
      return arr;
    };

    ArrayMethods.prototype.each = function(arr, block) {
      var idx, len;
      if (block.length > 0) {
        block = Block.supportMultipleArgs(block);
      }
      idx = -1;
      len = arr.length;
      while (++idx < arr.length) {
        block(arr[idx]);
      }
      return arr;
    };

    ArrayMethods.prototype.get = function(a, b) {
      return this.slice(a, b);
    };

    ArrayMethods.prototype.empty = function(arr) {
      return arr.length === 0;
    };

    ArrayMethods.prototype.fetch = function(arr, idx, default_or_block) {
      var len, orig;
      len = arr.length;
      orig = idx;
      if (idx < 0) {
        idx = idx + len;
      }
      if (idx < 0 || idx >= len) {
        if ((default_or_block != null ? default_or_block.call : void 0) != null) {
          return default_or_block(orig);
        }
        if (default_or_block !== void 0) {
          return default_or_block;
        }
        throw R.IndexError["new"]();
      }
      return arr[idx];
    };

    ArrayMethods.prototype.fill = function() {};

    ArrayMethods.prototype.insert = function() {
      var after, arr, el, i, idx, items, len, _i, _j, _k, _len, _len1, _ref1;
      arr = arguments[0], idx = arguments[1], items = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      if (idx === void 0) {
        throw R.ArgumentError["new"]();
      }
      if (items.length === 0) {
        return arr;
      }
      if (idx < 0) {
        idx = idx + arr.length + 1;
      }
      if (idx < 0) {
        throw R.IndexError["new"]();
      }
      after = arr.slice(idx);
      len = items.length;
      if (idx > arr.length) {
        for (i = _i = _ref1 = arr.length; _ref1 <= idx ? _i < idx : _i > idx; i = _ref1 <= idx ? ++_i : --_i) {
          arr[i] = null;
        }
      }
      for (i = _j = 0, _len = items.length; _j < _len; i = ++_j) {
        el = items[i];
        arr[idx + i] = el;
      }
      for (i = _k = 0, _len1 = after.length; _k < _len1; i = ++_k) {
        el = after[i];
        arr[idx + len + i] = el;
      }
      return arr;
    };

    ArrayMethods.prototype.join = function(arr, separator) {
      if (this.empty(arr)) {
        return '';
      }
      if (separator === void 0) {
        separator = R['$,'];
      }
      if (separator === null) {
        separator = '';
      }
      return _arr_join_.call(arr, separator);
    };

    ArrayMethods.prototype.reverse_each = function(coll, block) {
      var idx;
      if (block.length > 0) {
        block = Block.supportMultipleArgs(block);
      }
      idx = coll.length;
      while (idx--) {
        block(coll[idx]);
      }
      return coll;
    };

    ArrayMethods.prototype.__native_array_with__ = function(size, obj) {
      var ary, idx;
      ary = nativeArray(RCoerce.to_int_native(size));
      idx = -1;
      while (++idx < size) {
        ary[idx] = obj;
      }
      return ary;
    };

    return ArrayMethods;

  })(EnumerableMethods);

  _arr = R._arr = new ArrayMethods();

  StringMethods = (function() {

    function StringMethods() {}

    StringMethods.prototype.capitalize = function(str) {
      var a, b;
      if (str.length === 0) {
        return "";
      }
      b = this.downcase(str);
      a = this.upcase(str[0]);
      return a + b.slice(1);
    };

    StringMethods.prototype.center = function(str, length, padString) {
      var lft, max, rgt, size;
      if (padString == null) {
        padString = ' ';
      }
      if (padString.length === 0) {
        throw R.ArgumentError["new"]();
      }
      size = str.length;
      if (size >= length) {
        return str;
      }
      lft = Math.floor((length - size) / 2);
      rgt = length - size - lft;
      max = lft > rgt ? lft : rgt;
      padString = this.multiply(padString, max);
      return padString.slice(0, lft) + str + padString.slice(0, rgt);
    };

    StringMethods.prototype.chars = function(str, block) {
      var idx, len;
      idx = -1;
      len = str.length;
      while (++idx < len) {
        block(str[idx]);
      }
      return str;
    };

    StringMethods.prototype.chomp = function(str, sep) {
      var ending, regexp, _ref1;
      if (sep == null) {
        sep = null;
      }
      if (sep === null) {
        if (this.empty(str)) {
          return "";
        } else {
          return null;
        }
      } else {
        sep = RCoerce.to_str_native(sep);
        if (sep.length === 0) {
          regexp = /((\r\n)|\n)+$/;
        } else if (sep === "\n" || sep === "\r" || sep === "\r\n") {
          ending = ((_ref1 = str.match(/((\r\n)|\n|\r)$/)) != null ? _ref1[0] : void 0) || "\n";
          regexp = new RegExp("(" + (R.Regexp.escape(ending)) + ")$");
        } else {
          regexp = new RegExp("(" + (R.Regexp.escape(sep)) + ")$");
        }
        return str.replace(regexp, '');
      }
    };

    StringMethods.prototype.chop = function(str) {
      if (str.length === 0) {
        return str;
      }
      if (str.lastIndexOf("\r\n") === str.length - 2) {
        return str.replace(/\r\n$/, '');
      } else {
        return this.slice(str, 0, str.length - 1);
      }
    };

    StringMethods.prototype.count = function() {
      var args, str;
      str = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (args.length === 0) {
        throw R.ArgumentError["new"]();
      }
      return _str.__matched__(str, args).length;
    };

    StringMethods.prototype.__matched__ = function(str, args) {
      var el, rgx, _i, _len;
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        el = args[_i];
        rgx = _str.__to_regexp__(el);
        str = (str.match(rgx) || []).join('');
      }
      return str;
    };

    StringMethods.prototype.__to_regexp__ = function(str) {
      var r;
      r = "";
      if (str.length === 0) {
        r = "(?!)";
      } else if (str === '^') {
        r = "\\^";
      } else {
        if (str.lastIndexOf("^") >= 1) {
          str = str[0] + str.slice(1).replace("^", "\\^");
        }
        r = "[" + str + "]";
      }
      try {
        return new RegExp(r, 'g');
      } catch (e) {
        throw R.ArgumentError["new"]();
      }
    };

    StringMethods.prototype['delete'] = function() {
      var args, str, trash;
      str = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (args.length === 0) {
        throw R.ArgumentError["new"]();
      }
      trash = _str.__matched__(str, args);
      return str.replace(new RegExp("[" + trash + "]", 'g'), '');
    };

    StringMethods.prototype.squeeze = function() {
      var all, c, chars, i, j, last, len, pattern, str, trash;
      str = arguments[0], pattern = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      trash = _str.__matched__(str, pattern);
      chars = str.split("");
      len = str.length;
      i = 1;
      j = 0;
      last = chars[0];
      all = pattern.length === 0;
      while (i < len) {
        c = chars[i];
        if (!(c === last && (all || trash.indexOf(c) >= 0))) {
          chars[j += 1] = last = c;
        }
        i += 1;
      }
      if ((j + 1) < len) {
        chars = chars.slice(0, j + 1 || 9e9);
      }
      return chars.join('');
    };

    StringMethods.prototype.downcase = function(str) {
      if (!str.match(/[A-Z]/)) {
        return str;
      }
      return _arr.map(str.split(''), function(c) {
        if (c.match(/[A-Z]/)) {
          return c.toLowerCase();
        } else {
          return c;
        }
      }).join('');
    };

    StringMethods.prototype.empty = function(str) {
      return str.length === 0;
    };

    StringMethods.prototype.end_with = function() {
      var needles, str, w, _i, _len;
      str = arguments[0], needles = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      for (_i = 0, _len = needles.length; _i < _len; _i++) {
        w = needles[_i];
        if (str.lastIndexOf(w) + w.length === str.length) {
          return true;
        }
      }
      return false;
    };

    StringMethods.prototype.include = function(str, other) {
      return str.indexOf(other) >= 0;
    };

    StringMethods.prototype.index = function(str, needle, offset) {
      var idx;
      if (offset != null) {
        if (offset < 0) {
          offset = str.length + offset;
        }
      }
      if ((offset != null) && (offset > str.length || offset < 0)) {
        return null;
      }
      idx = str.indexOf(needle, offset);
      if (idx < 0) {
        return null;
      } else {
        return idx;
      }
    };

    StringMethods.prototype.ljust = function(str, width, padString) {
      var idx, len, out, pad_length;
      if (padString == null) {
        padString = " ";
      }
      len = str.length;
      if (len >= width) {
        return str;
      } else {
        if (padString.length === 0) {
          throw R.ArgumentError["new"]();
        }
        pad_length = width - len;
        idx = -1;
        out = "";
        while (++idx <= pad_length) {
          out += padString;
        }
        return str + out.slice(0, pad_length);
      }
    };

    StringMethods.prototype.lstrip = function(str) {
      return str.replace(/^[\s\n\t]+/g, '');
    };

    StringMethods.prototype.match = function(str, pattern, offset, block) {
      var matches, opts, result;
      if (offset == null) {
        offset = null;
      }
      if (block == null) {
        if ((offset != null ? offset.call : void 0) != null) {
          block = offset;
          offset = null;
        }
      }
      opts = {};
      if (offset != null) {
        opts = {
          string: str,
          offset: offset
        };
        str = str.slice(offset);
        matches = str.match(pattern, offset);
      } else {
        matches = str.match(pattern);
      }
      result = matches ? new R.MatchData(matches, opts) : null;
      R['$~'] = result;
      if (block) {
        if (result) {
          return block(result);
        } else {
          return [];
        }
      } else {
        return result;
      }
    };

    StringMethods.prototype.multiply = function(str, num) {
      var n, out, _i;
      if (num < 0) {
        throw R.ArgumentError["new"]();
      }
      out = "";
      for (n = _i = 0; 0 <= num ? _i < num : _i > num; n = 0 <= num ? ++_i : --_i) {
        out += str;
      }
      return out;
    };

    StringMethods.prototype.partition = function(str, pattern) {
      var a, b, c, idx, start;
      idx = this.index(str, pattern);
      if (idx !== null) {
        start = idx + pattern.length;
        a = this.slice(str, 0, idx) || '';
        b = pattern;
        c = str.slice(start);
        return [a, b, c];
      } else {
        return [str, '', ''];
      }
    };

    StringMethods.prototype.reverse = function(str) {
      return str.split("").reverse().join("");
    };

    StringMethods.prototype.rjust = function(str, width, pad_str) {
      var len, pad_len;
      if (pad_str == null) {
        pad_str = " ";
      }
      len = str.length;
      if (len >= width) {
        return str;
      } else {
        if (pad_str.length === 0) {
          throw R.ArgumentError["new"]();
        }
        pad_len = width - len;
        return _str.multiply(pad_str, pad_len).slice(0, pad_len) + str;
      }
    };

    StringMethods.prototype.slice = function(str, index, other) {
      var length, size, start;
      if (index === null) {
        throw R.TypeError["new"]();
      }
      size = str.length;
      if (other !== void 0) {
        if (index.is_regexp != null) {
          throw R.NotImplementedError["new"]();
        } else {
          length = other;
          start = index;
          if (start < 0) {
            start += size;
          }
          if (length < 0 || start < 0 || start > size) {
            return null;
          }
          return str.slice(start, start + length);
        }
      }
      if (index.is_regexp != null) {
        throw R.NotImplementedError["new"]();
      } else if (typeof index === 'string') {
        if (this.include(str, index)) {
          return index;
        } else {
          return null;
        }
      } else if (index.is_range != null) {
        start = RCoerce.to_int_native(index.begin());
        length = RCoerce.to_int_native(index.end());
        if (start < 0) {
          start += size;
        }
        if (length < 0) {
          length += size;
        }
        if (!index.exclude_end()) {
          length += 1;
        }
        if (start === size) {
          return "";
        }
        if (start < 0 || start > size) {
          return null;
        }
        if (length > size) {
          length = size;
        }
        length = length - start;
        if (length < 0) {
          length = 0;
        }
        return str.slice(start, start + length);
      } else {
        if (index < 0) {
          index += size;
        }
        if (index < 0 || index >= size) {
          return null;
        }
        return str[index];
      }
    };

    StringMethods.prototype.start_with = function() {
      var needle, needles, str, _i, _len;
      str = arguments[0], needles = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      for (_i = 0, _len = needles.length; _i < _len; _i++) {
        needle = needles[_i];
        if (str.indexOf(needle) === 0) {
          return true;
        }
      }
      return false;
    };

    StringMethods.prototype.upcase = function(str) {
      if (!str.match(/[a-z]/)) {
        return str;
      }
      return _arr.map(str.split(''), function(c) {
        if (c.match(/[a-z]/)) {
          return c.toUpperCase();
        } else {
          return c;
        }
      }).join('');
    };

    return StringMethods;

  })();

  _str = R._str = new StringMethods();

  errors = ['ArgumentError', 'RegexpError', 'TypeError', 'KeyError', 'IndexError', 'FloatDomainError', 'RangeError', 'StandardError', 'ZeroDivisionError', 'NotSupportedError', 'NotImplementedError'];

  _fn = function(error) {
    var errorClass;
    errorClass = (function(_super) {

      __extends(_Class, _super);

      function _Class() {
        return _Class.__super__.constructor.apply(this, arguments);
      }

      return _Class;

    })(Error);
    errorClass["new"] = function() {
      return new RubyJS[error](error);
    };
    return RubyJS[error] = errorClass;
  };
  for (_i = 0, _len = errors.length; _i < _len; _i++) {
    error = errors[_i];
    _fn(error);
  }

  RubyJS.Comparable = (function() {

    function Comparable() {}

    Comparable.prototype['<'] = function(other) {
      var cmp;
      cmp = this['<=>'](other);
      if (cmp === null) {
        throw R.TypeError["new"]();
      }
      return cmp < 0;
    };

    Comparable.prototype['>'] = function(other) {
      var cmp;
      cmp = this['<=>'](other);
      if (cmp === null) {
        throw R.TypeError["new"]();
      }
      return cmp > 0;
    };

    Comparable.prototype['<='] = function(other) {
      var cmp;
      cmp = this['<=>'](other);
      if (cmp === null) {
        throw R.TypeError["new"]();
      }
      return cmp <= 0;
    };

    Comparable.prototype['>='] = function(other) {
      var cmp;
      cmp = this['<=>'](other);
      if (cmp === null) {
        throw R.TypeError["new"]();
      }
      return cmp >= 0;
    };

    Comparable.prototype.between = function(min, max) {
      return this['>='](min) && this['<='](max);
    };

    Comparable.cmp = function(a, b) {
      if (typeof a !== 'object' && typeof a === typeof b) {
        if (a === b) {
          return 0;
        } else {
          if (a < b) {
            return -1;
          } else {
            return 1;
          }
        }
      } else {
        a = R(a);
        if (a['<=>'] == null) {
          throw 'NoMethodError';
        }
        return a['<=>'](b);
      }
    };

    Comparable.cmpstrict = function(a, b) {
      var cmp;
      if (typeof a === typeof b && typeof a !== 'object') {
        if (a === b) {
          return 0;
        } else {
          if (a < b) {
            return -1;
          } else {
            return 1;
          }
        }
      } else {
        a = R(a);
        if (a['<=>'] == null) {
          throw 'NoMethodError';
        }
        cmp = a['<=>'](b);
        if (cmp === null) {
          throw R.ArgumentError["new"]();
        }
        return cmp;
      }
    };

    Comparable.prototype.cmp = Comparable.prototype['<=>'];

    Comparable.prototype.lt = Comparable.prototype['<'];

    Comparable.prototype.lteq = Comparable.prototype['<='];

    Comparable.prototype.gt = Comparable.prototype['>'];

    Comparable.prototype.gteq = Comparable.prototype['>='];

    return Comparable;

  })();

  RubyJS.Enumerable = (function() {

    function Enumerable() {}

    Enumerable.prototype.all = function(block) {
      return _enum.all(this, block);
    };

    Enumerable.prototype.any = function(block) {
      return _enum.any(this, block);
    };

    Enumerable.prototype.collect_concat = function(block) {
      if (block == null) {
        block = null;
      }
      if (!(block && (block.call != null))) {
        return this.to_enum('collect_concat');
      }
      return new RArray(_enum.collect_concat(this, block));
    };

    Enumerable.prototype.flat_map = Enumerable.prototype.collect_concat;

    Enumerable.prototype.count = function(block) {
      return new R.Fixnum(_enum.count(this, block));
    };

    Enumerable.prototype.cycle = function(n, block) {
      if (arguments.length > 2) {
        throw R.ArgumentError["new"]();
      }
      return _enum.cycle(this, n, block);
    };

    Enumerable.prototype.drop = function(n) {
      this.__ensure_args_length(arguments, 1);
      n = RCoerce.to_int_native(n);
      if (n < 0) {
        throw R.ArgumentError["new"]();
      }
      return new RArray(_enum.drop(this, n));
    };

    Enumerable.prototype.drop_while = function(block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('drop_while');
      }
      return new RArray(_enum.drop_while(this, block));
    };

    Enumerable.prototype.each_cons = function() {
      var args, block, n;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      block = this.__extract_block(args);
      if (!(block && (block.call != null))) {
        return this.to_enum.apply(this, ['each_cons'].concat(__slice.call(args)));
      }
      this.__ensure_args_length(args, 1);
      n = RCoerce.to_int_native(args[0]);
      if (!(n > 0)) {
        throw R.ArgumentError["new"]();
      }
      return _enum.each_cons(this, n, block);
    };

    Enumerable.prototype.each_entry = function(block) {
      if (arguments.length > 1) {
        throw R.ArgumentError["new"]();
      }
      if (!(block && (block.call != null))) {
        return this.to_enum('each_entry');
      }
      return _enum.each_entry(this, block);
    };

    Enumerable.prototype.each_slice = function(n, block) {
      if (!n) {
        throw R.ArgumentError["new"]();
      }
      n = RCoerce.to_int_native(n);
      if (n <= 0) {
        throw R.ArgumentError["new"]();
      }
      if (block && !(block.call != null)) {
        throw R.ArgumentError["new"]();
      }
      if (block === void 0) {
        return this.to_enum('each_slice', n);
      }
      return _enum.each_slice(this, n, block);
    };

    Enumerable.prototype.each_with_index = function(block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('each_with_index');
      }
      return _enum.each_with_index(this, block);
    };

    Enumerable.prototype.each_with_object = function(obj, block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('each_with_object', obj);
      }
      return _enum.each_with_object(this, obj, block);
    };

    Enumerable.prototype.find = function(ifnone, block) {
      if (block == null) {
        block = null;
      }
      return _enum.find(this, ifnone, block);
    };

    Enumerable.prototype.detect = Enumerable.prototype.find;

    Enumerable.prototype.find_all = function(block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('find_all');
      }
      return new RArray(_enum.select(this, block));
    };

    Enumerable.prototype.select = Enumerable.prototype.find_all;

    Enumerable.prototype.find_index = function(value) {
      var val;
      if (arguments.length === 0) {
        return this.to_enum('find_index');
      }
      val = _enum.find_index(this, value);
      if (val !== null) {
        return new R.Fixnum(val);
      } else {
        return val;
      }
    };

    Enumerable.prototype.first = function(n) {
      if (n === null || n === void 0) {
        return _enum.first(this, null);
      } else {
        n = RCoerce.to_int_native(n);
        return new RArray(_enum.first(this, n));
      }
    };

    Enumerable.prototype.include = function(other) {
      return _enum.include(this, other);
    };

    Enumerable.prototype.inject = function(init, sym, block) {
      return _enum.inject(this, init, sym, block);
    };

    Enumerable.prototype.iterator = function() {
      return this.each();
    };

    Enumerable.prototype.grep = function(pattern, block) {
      return new RArray(_enum.grep(this, pattern, block));
    };

    Enumerable.prototype.group_by = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('group_by');
      }
      return _enum.group_by(this, block);
    };

    Enumerable.prototype.map = function(block) {
      var arr, callback;
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('map');
      }
      callback = R.blockify(block, this);
      arr = [];
      this.each(function() {
        return arr.push(callback.invoke(arguments));
      });
      return new RArray(arr);
    };

    Enumerable.prototype.collect = Enumerable.prototype.map;

    Enumerable.prototype.member = Enumerable.prototype.include;

    Enumerable.prototype.max = function(block) {
      return _enum.max(this, block);
    };

    Enumerable.prototype.max_by = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('max_by');
      }
      return _enum.max_by(this, block);
    };

    Enumerable.prototype.min = function(block) {
      return _enum.min(this, block);
    };

    Enumerable.prototype.min_by = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('min_by');
      }
      return _enum.min_by(this, block);
    };

    Enumerable.prototype.minmax = function(block) {
      return new RArray(_enum.minmax(this, block));
    };

    Enumerable.prototype.minmax_by = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('minmax_by');
      }
      return new RArray(_enum.minmax_by(this, block));
    };

    Enumerable.prototype.none = function(block) {
      return _enum.none(this, block);
    };

    Enumerable.prototype.one = function(block) {
      return _enum.one(this, block);
    };

    Enumerable.prototype.partition = function(block) {
      var ary;
      if (!(block && (block.call != null))) {
        return this.to_enum('partition');
      }
      ary = _enum.partition(this, block);
      return new RArray([new RArray(ary[0]), new RArray(ary[1])]);
    };

    Enumerable.prototype.reduce = Enumerable.prototype.inject;

    Enumerable.prototype.reject = function(block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('reject');
      }
      return new RArray(_enum.reject(this, block));
    };

    Enumerable.prototype.reverse_each = function(block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('reverse_each');
      }
      return _enum.reverse_each(this, block);
    };

    Enumerable.prototype.slice_before = function() {
      var arg, args, block, has_init, self;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      block = this.__extract_block(args);
      arg = R(args[0]);
      if (block) {
        has_init = !(arg === void 0);
      } else {
        block = function(elem) {
          return arg['==='](elem);
        };
      }
      self = this;
      return R.Enumerator.create(function(yielder) {
        var accumulator;
        accumulator = null;
        self.each(function(elem) {
          var start_new;
          start_new = has_init ? block(elem, arg.dup()) : block(elem);
          if (start_new) {
            if (accumulator) {
              yielder["yield"](accumulator);
            }
            return accumulator = R([elem]);
          } else {
            accumulator || (accumulator = new RArray([]));
            return accumulator.append(elem);
          }
        });
        if (accumulator) {
          return yielder["yield"](accumulator);
        }
      });
    };

    Enumerable.prototype.sort = function(block) {
      return new RArray(_enum.sort(this, block));
    };

    Enumerable.prototype.sort_by = function(block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('sort_by');
      }
      return new RArray(_enum.sort_by(this, block));
    };

    Enumerable.prototype.take = function(n) {
      this.__ensure_args_length(arguments, 1);
      n = RCoerce.to_int_native(n);
      if (n < 0) {
        throw R.ArgumentError["new"]();
      }
      return new RArray(_enum.take(this, n));
    };

    Enumerable.prototype.take_while = function(block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('take_while');
      }
      return new RArray(_enum.take_while(this, block));
    };

    Enumerable.prototype.to_a = function() {
      return new RArray(_enum.to_a(this));
    };

    Enumerable.prototype.to_enum = function() {
      var args, iter;
      iter = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (iter == null) {
        iter = "each";
      }
      return new R.Enumerator(this, iter, args);
    };

    Enumerable.prototype.entries = Enumerable.prototype.to_a;

    Enumerable.prototype.zip = function() {
      var block, idx, others, results;
      others = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      block = this.__extract_block(others);
      others = R(others).map(function(other) {
        var o;
        o = R(other);
        if (o.to_ary != null) {
          return o.to_ary();
        } else {
          return o.to_enum('each');
        }
      });
      results = new R.Array([]);
      idx = 0;
      this.each(function(el) {
        var inner;
        inner = R([el]);
        others.each(function(other) {
          el = other.is_array != null ? other.at(idx) : other.next();
          if (el === void 0) {
            el = null;
          }
          return inner.append(el);
        });
        if (block) {
          block(inner);
        }
        results.append(inner);
        return idx += 1;
      });
      if (block) {
        return null;
      } else {
        return results;
      }
    };

    Enumerable.prototype.collectConcat = Enumerable.prototype.collect_concat;

    Enumerable.prototype.dropWhile = Enumerable.prototype.drop_while;

    Enumerable.prototype.eachCons = Enumerable.prototype.each_cons;

    Enumerable.prototype.eachEntry = Enumerable.prototype.each_entry;

    Enumerable.prototype.eachSlice = Enumerable.prototype.each_slice;

    Enumerable.prototype.eachWithIndex = Enumerable.prototype.each_with_index;

    Enumerable.prototype.eachWithObject = Enumerable.prototype.each_with_object;

    Enumerable.prototype.findAll = Enumerable.prototype.find_all;

    Enumerable.prototype.findIndex = Enumerable.prototype.find_index;

    Enumerable.prototype.flatMap = Enumerable.prototype.flat_map;

    Enumerable.prototype.groupBy = Enumerable.prototype.group_by;

    Enumerable.prototype.maxBy = Enumerable.prototype.max_by;

    Enumerable.prototype.minBy = Enumerable.prototype.min_by;

    Enumerable.prototype.minmaxBy = Enumerable.prototype.minmax_by;

    Enumerable.prototype.reverseEach = Enumerable.prototype.reverse_each;

    Enumerable.prototype.sliceBefore = Enumerable.prototype.slice_before;

    Enumerable.prototype.sortBy = Enumerable.prototype.sort_by;

    Enumerable.prototype.takeWhile = Enumerable.prototype.take_while;

    Enumerable.prototype.toA = Enumerable.prototype.to_a;

    return Enumerable;

  })();

  RubyJS.Enumerable.SortedElement = (function() {

    function SortedElement(value, sort_by) {
      this.value = value;
      this.sort_by = sort_by;
    }

    SortedElement.prototype['<=>'] = function(other) {
      var _ref1;
      return (_ref1 = this.sort_by) != null ? _ref1['<=>'](other.sort_by) : void 0;
    };

    return SortedElement;

  })();

  REnumerable = RubyJS.Enumerable;

  RubyJS.Enumerator = (function(_super) {

    __extends(Enumerator, _super);

    Enumerator.include(RubyJS.Enumerable);

    Enumerator["new"] = function() {
      var args, iter, obj;
      obj = arguments[0], iter = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      return new RubyJS.Enumerator(obj, iter, args);
    };

    function Enumerator(object, iter, args) {
      this.object = object;
      this.iter = iter != null ? iter : 'each';
      this.args = args != null ? args : [];
      this.generator = null;
      this.length = this.object.length;
      this.idx = 0;
    }

    Enumerator.create = function() {
      var args, block, iter, object;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (block = R.__extract_block(args)) {
        object = new RubyJS.Enumerator.Generator(block);
        iter = 'each';
        return Enumerator["new"](object, iter);
      }
    };

    Enumerator.prototype.is_enumerator = function() {
      return true;
    };

    Enumerator.prototype.each = function(block) {
      var _ref1;
      return (_ref1 = this.object)[this.iter].apply(_ref1, __slice.call(this.args).concat([block]));
    };

    Enumerator.prototype.each_with_index = function(block) {
      var callback, idx;
      if (!(block && (block.call != null))) {
        return this.to_enum('each_with_index');
      }
      callback = R.blockify(block, this);
      idx = 0;
      return this.each(function() {
        var args, val;
        args = BlockMulti.prototype.args(arguments);
        val = callback.invokeSplat(args, idx);
        idx += 1;
        return val;
      });
    };

    Enumerator.prototype.size = function() {
      return this.object.length;
    };

    Enumerator.prototype.iterator = function() {
      return this.to_a().to_native();
    };

    Enumerator.prototype.native_array = function() {
      return this.arr || (this.arr = this.iterator());
    };

    Enumerator.prototype.next = function() {
      var idx;
      idx = this.idx;
      this.idx += 1;
      return this.native_array()[idx];
    };

    Enumerator.prototype.to_enum = function() {
      var args, iter;
      iter = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (iter == null) {
        iter = "each";
      }
      return new RubyJS.Enumerator(this, iter, args);
    };

    Enumerator.prototype.eachWithIndex = Enumerator.prototype.each_with_index;

    return Enumerator;

  })(RubyJS.Object);

  RubyJS.Enumerator.Yielder = (function(_super) {

    __extends(Yielder, _super);

    function Yielder(proc) {
      this.proc = proc;
      if (this.proc.call == null) {
        throw 'LocalJumpError';
      }
    }

    Yielder.prototype["yield"] = function() {
      return this.proc.apply(this, arguments);
    };

    Yielder.prototype['<<'] = function(value) {
      this["yield"](value);
      return this;
    };

    return Yielder;

  })(RubyJS.Object);

  RubyJS.Enumerator.Generator = (function(_super) {

    __extends(Generator, _super);

    function Generator(proc) {
      this.proc = proc;
      if (this.proc.call == null) {
        throw 'LocalJumpError';
      }
    }

    Generator.prototype.each = function(block) {
      var enclosed_yield;
      enclosed_yield = function() {
        return block.apply(this, arguments);
      };
      return this.proc(new RubyJS.Enumerator.Yielder(enclosed_yield));
    };

    return Generator;

  })(RubyJS.Object);

  RubyJS.Array = (function(_super) {

    __extends(Array, _super);

    Array.include(R.Enumerable);

    Array.prototype.is_array = function() {
      return true;
    };

    Array.prototype.iterator = function() {
      return this.__native__;
    };

    function Array(__native__, recursive) {
      var idx, len;
      this.__native__ = __native__ != null ? __native__ : [];
      if (recursive === true) {
        idx = -1;
        len = this.__native__.length;
        while (++idx < len) {
          this.__native__[idx] = R(this.__native__[idx], recursive);
        }
      }
    }

    Array["new"] = function() {
      var args, ary, block, idx, obj, size;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      block = R.__extract_block(args);
      if (args.length >= 3) {
        throw R.ArgumentError["new"]();
      }
      size = args[0];
      obj = args[1];
      if (size === void 0) {
        return new R.Array([]);
      }
      if (obj !== void 0 && (this.isNativeArray(size) || (size.is_array != null))) {
        throw R.TypeError["new"]();
      }
      if (this.isNativeArray(size)) {
        return new R.Array(size);
      }
      if ((size.to_ary != null) && obj === void 0) {
        return size.to_ary();
      }
      size = RCoerce.to_int_native(size);
      if (size < 0) {
        throw R.ArgumentError["new"]();
      }
      if (obj === void 0) {
        obj = null;
      }
      ary = [];
      idx = -1;
      while (++idx < size) {
        ary[idx] = block ? block(R(idx)) : obj;
      }
      return new R.Array(ary);
    };

    Array.typecast = function(arr, recursive) {
      return new R.Array(arr, recursive);
    };

    Array.isNativeArray = nativeArray.isArray || function(obj) {
      return _toString_.call(obj) === '[object Array]';
    };

    Array.try_convert = function(obj) {
      if (obj.is_array != null) {
        return obj;
      }
      if (this.isNativeArray(obj)) {
        return this["new"](obj);
      }
      if (obj.to_ary != null) {
        return obj.to_ary();
      } else {
        return null;
      }
    };

    Array.prototype.valueOf = function() {
      return this.__native__;
    };

    Array.prototype.to_native = function(recursive) {
      var ary, el, idx, len, _ref1;
      if (recursive == null) {
        recursive = false;
      }
      if (recursive) {
        _ref1 = this.__iter_vars__(), idx = _ref1[0], len = _ref1[1], ary = _ref1[2];
        while (++idx < len) {
          el = this.__native__[idx];
          if (el && (el.to_native != null)) {
            el = el.to_native(true);
          }
          ary[idx] = el;
        }
        return ary;
      } else {
        return this.__native__.slice(0);
      }
    };

    Array.prototype.unbox = Array.prototype.to_native;

    Array.prototype.to_native_clone = function() {
      return this.__native__.slice(0);
    };

    Array.prototype.__iter_vars__ = function(no_array) {
      var len;
      len = this.__native__.length;
      if (no_array) {
        return [-1, len];
      } else {
        return [-1, len, nativeArray(len)];
      }
    };

    Array.prototype['=='] = function(other) {
      other = R(other);
      if (other.is_array == null) {
        if (other.to_ary == null) {
          return false;
        }
        return other.equals(this);
      }
      return _arr.equals(this.__native__, other.__native__);
    };

    Array.prototype['<<'] = function(obj) {
      this.__native__.push(obj);
      return this;
    };

    Array.prototype['&'] = function(other) {
      var arr;
      other = RCoerce.to_ary(other);
      arr = new R.Array([]);
      this.each(function(el) {
        if (other.include(el)) {
          return arr.push(el);
        }
      });
      return arr.uniq();
    };

    Array.prototype['<=>'] = function(other) {
      var diff, i, other_total, total;
      if (other == null) {
        return null;
      }
      try {
        other = RCoerce.to_ary(other);
      } catch (e) {
        return null;
      }
      if (this.equals(other)) {
        return 0;
      }
      other_total = other.size();
      i = 0;
      total = other_total.lt(this.size()) ? other_total : this.size();
      while (total.gt(i)) {
        diff = R(this.__native__[i])['<=>'](other.__native__[i]);
        if (diff !== 0) {
          return diff;
        }
        i += 1;
      }
      return this.size()['<=>'](other_total);
    };

    Array.prototype.at = function(index) {
      index = RCoerce.to_int_native(index);
      return _arr.at(this.__native__, index);
    };

    Array.prototype.clear = function() {
      this.__ensure_args_length(arguments, 0);
      this.__native__.length = 0;
      this.replace(this.__native__);
      return this;
    };

    Array.prototype.clone = function() {
      return this.dup();
    };

    Array.prototype.collect_bang = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('collect_bang');
      }
      return this.replace(_arr.collect(this.__native__, block));
    };

    Array.prototype.combination = function() {
      var args, block, num;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      block = this.__extract_block(args);
      num = RCoerce.to_int_native(args[0]);
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('combination', num);
      }
      _arr.combination(this.__native__, num, block);
      return this;
    };

    Array.prototype.compact = function() {
      return new RArray(_arr.compact(this.__native__));
    };

    Array.prototype.compact_bang = function() {
      var ary, len;
      len = this.__native__.length;
      ary = _arr.compact(this.__native__);
      this.replace(ary);
      if (len === ary.length) {
        return null;
      } else {
        return this;
      }
    };

    Array.prototype.concat = function(other) {
      other = RCoerce.to_ary_native(other);
      return this.replace(this.__native__.concat(other));
    };

    Array.prototype["delete"] = function() {
      var args, block;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      block = this.__extract_block(args);
      return _arr["delete"](this.__native__, args[0], block);
    };

    Array.prototype.delete_at = function(idx) {
      idx = RCoerce.to_int_native(idx);
      return _arr.delete_at(this.__native__, idx);
    };

    Array.prototype.delete_if = function(block) {
      return this.replace(this.reject(block));
    };

    Array.prototype.dup = function() {
      return new RubyJS.Array(this.__native__.slice(0));
    };

    Array.prototype.eql = function(other) {
      var other_arr;
      if (this.equals(other)) {
        return true;
      }
      other = R(other);
      if (other.is_array == null) {
        return false;
      }
      if (!this.size().equals(other.size())) {
        return false;
      }
      other_arr = other.to_native();
      return this.catch_break(function(breaker) {
        var i;
        i = 0;
        this.each(function(x) {
          if (!R(x).eql(other_arr[i])) {
            breaker["break"](false);
          }
          return i += 1;
        });
        return true;
      });
    };

    Array.prototype.each_index = function(block) {
      var idx, len;
      if (block && (block.call != null)) {
        idx = -1;
        len = this.__native__.length;
        while (++idx < len) {
          block(idx);
        }
        return this;
      } else {
        return this.to_enum('each_index');
      }
    };

    Array.prototype.each = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum();
      }
      _arr.each(this.__native__, block);
      return this;
    };

    Array.prototype.get = function(a, b) {
      return this.slice(a, b);
    };

    Array.prototype.set = function(idx, obj) {
      if (idx.is_range != null) {
        return this.set$range(idx, obj);
      }
      if (arguments.length === 3) {
        return this.set$int$int.apply(this, arguments);
      }
      idx = RCoerce.to_int_native(idx);
      this.__native__[idx] = obj;
      return obj;
    };

    Array.prototype.set$range = function(rng, obj) {
      throw R.NotImplementedError["new"]();
    };

    Array.prototype.set$int$int = function(start, length, obj) {
      throw R.NotImplementedError["new"]();
    };

    Array.prototype.empty = function() {
      return this.__native__.length === 0;
    };

    Array.prototype.fetch = function(idx, default_or_block) {
      idx = RCoerce.to_int_native(idx);
      return _arr.fetch(this.__native__, idx, default_or_block);
    };

    Array.prototype.fill = function() {
      var args, block, fill, i, left, obj, one, right, size, total, two, v;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        throw R.ArgumentError["new"]();
      }
      block = this.__extract_block(args);
      if (block) {
        if (args.length >= 3) {
          throw R.ArgumentError["new"]();
        }
        one = args[0];
        two = args[1];
      } else {
        if (args.length > 3) {
          throw R.ArgumentError["new"]();
        }
        obj = args[0];
        one = args[1];
        two = args[2];
      }
      size = this.__size__();
      if ((one != null ? one.is_range : void 0) != null) {
        throw R.NotImplementedError["new"]();
      } else if (one !== void 0 && one !== null) {
        left = RCoerce.to_int_native(one);
        if (left < 0) {
          left = left + size;
        }
        if (left < 0) {
          left = 0;
        }
        if (two !== void 0 && two !== null) {
          try {
            right = RCoerce.to_int_native(two);
          } catch (e) {
            throw R.ArgumentError["new"]("second argument must be a Fixnum");
          }
          if (right === 0) {
            return this;
          }
          right = right + left;
        } else {
          right = size;
        }
      } else {
        left = 0;
        right = size;
      }
      total = right;
      if (right > size) {
        fill = this.__native_array_with__(right - size, null);
        this.concat(fill);
        total = right;
      }
      i = left;
      if (block) {
        while (total > i) {
          v = block.call(this, i);
          this.__native__[i] = v === void 0 ? null : v;
          i += 1;
        }
      } else {
        while (total > i) {
          this.__native__[i] = obj;
          i += 1;
        }
      }
      return this;
    };

    Array.prototype.flatten = function(recursion) {
      if (recursion == null) {
        recursion = -1;
      }
      return new RArray(_arr.flatten(this.__native__, recursion));
    };

    Array.prototype.insert = function() {
      var ary, idx, items;
      idx = arguments[0], items = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (idx === void 0) {
        throw R.ArgumentError["new"]();
      }
      if (items.length === 0) {
        return this;
      }
      idx = RCoerce.to_int_native(idx);
      ary = _arr.insert.apply(_arr, [this.__native__, idx].concat(items));
      return this;
    };

    Array.prototype.inspect = function() {
      return R("[" + (this.map(function(e) {
        return R.inspect(e);
      }).join(', ')) + "]");
    };

    Array.prototype.join = function(sep) {
      if (sep != null) {
        sep = RCoerce.to_str_native(sep);
      }
      return new RString(_arr.join(this.__native__, sep));
    };

    Array.prototype.keep_if = function(block) {
      var ary;
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('keep_if');
      }
      ary = [];
      this.each(function(el) {
        if (!R.falsey(block(el))) {
          return ary.push(el);
        }
      });
      if (this.__size__() === ary.length) {
        return this;
      } else {
        return this.replace(ary);
      }
    };

    Array.prototype.minus = function(other) {
      var ary;
      other = RCoerce.to_ary(other);
      ary = [];
      this.each(function(el) {
        if (!other.include(el)) {
          return ary.push(el);
        }
      });
      return new R.Array(ary);
    };

    Array.prototype.multiply = function(multiplier) {
      var arr, ary, idx, total;
      this.__ensure_args_length(arguments, 1);
      if (multiplier === null) {
        throw R.TypeError["new"]();
      }
      multiplier = R(multiplier);
      if (multiplier.to_str != null) {
        return this.join(multiplier);
      } else {
        multiplier = RCoerce.to_int_native(multiplier);
        if (multiplier < 0) {
          throw R.ArgumentError["new"]("count cannot be negative");
        }
        total = this.__size__();
        if (total === 0) {
          return new R.Array([]);
        } else if (total === 1) {
          return this.dup();
        }
        ary = [];
        arr = this.__native__;
        idx = -1;
        while (++idx < multiplier) {
          ary = ary.concat(arr);
        }
        return new R.Array(ary);
      }
    };

    Array.prototype.last = function(n) {
      var len;
      len = this.__size__();
      if (len < 1) {
        if (n === void 0) {
          return null;
        }
        return new R.Array([]);
      }
      if (n === void 0) {
        return this.at(-1);
      }
      n = RCoerce.to_int_native(n);
      if (n === 0) {
        return new R.Array([]);
      }
      if (n < 0) {
        throw R.ArgumentError["new"]("count must be positive");
      }
      if (n > len) {
        n = len;
      }
      return new R.Array(this.__native__.slice(-n));
    };

    Array.prototype.permutation = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      throw R.NotImplementedError["new"]();
    };

    Array.prototype.plus = function(other) {
      return this.concat(other);
    };

    Array.prototype.pop = function(many) {
      var first;
      if (arguments.length > 1) {
        throw R.ArgumentError["new"]();
      }
      if (many === void 0) {
        return this.__native__.pop();
      } else {
        many = RCoerce.to_int_native(many);
        if (many < 0) {
          throw R.ArgumentError["new"]("negative array size");
        }
        first = this.__size__() - many;
        if (first < 0) {
          first = 0;
        }
        return this.slice_bang(first, many);
      }
    };

    Array.prototype.product = function() {
      var args, block, block_result, outer, result;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      block = this.__extract_block(args);
      args = R.$Array_r(args).reverse();
      if (!args.all(function(a) {
        return a.to_ary != null;
      })) {
        throw R.TypeError["new"]();
      }
      args.map_bang(function(a) {
        return a.to_ary();
      });
      result = new R.Array([]);
      args.push(this);
      outer = args.inject(result.push, function(trigger, values) {
        return function(partial) {
          return values.each(function(val) {
            return trigger.call(result, partial.dup().append(val));
          });
        };
      });
      outer(new R.Array([]));
      if (block) {
        block_result = this;
        result.each(function(v) {
          return block_result.append(block(v));
        });
        return block_result;
      } else {
        return result;
      }
    };

    Array.prototype.push = function() {
      this.__native__.push.apply(this.__native__, arguments);
      return this;
    };

    Array.prototype.rassoc = function(obj) {
      obj = R(obj);
      return this.catch_break(function(breaker) {
        this.each(function(elem) {
          var _ref1;
          if ((elem.is_array != null) && ((_ref1 = R(elem.at(1))) != null ? _ref1['=='](obj) : void 0)) {
            return breaker["break"](elem);
          }
        });
        return null;
      });
    };

    Array.prototype.rindex = function(other) {
      var block, len, ridx;
      if (other === void 0) {
        return this.to_enum('rindex');
      }
      if (other.call != null) {
        block = other;
        len = this.__size__();
        ridx = this.catch_break(function(breaker) {
          var idx;
          idx = -1;
          this.reverse_each(function(el) {
            idx += 1;
            if (!R.falsey(block(el))) {
              return breaker["break"](idx);
            }
          });
          return null;
        });
      } else {
        ridx = this.catch_break(function(breaker) {
          var idx;
          idx = -1;
          this.reverse_each(function(el) {
            idx += 1;
            if (R(el)['=='](other)) {
              return breaker["break"](idx);
            }
          });
          return null;
        });
      }
      if (ridx === null) {
        return null;
      } else {
        return R(this.__size__() - ridx - 1);
      }
    };

    Array.prototype.sample = function(n, range) {
      var ary, idx, ridx, size, tmp;
      if (range == null) {
        range = void 0;
      }
      if (n === void 0) {
        return this.at(this.rand(this.size()));
      }
      n = RCoerce.to_int_native(n);
      if (n < 0) {
        throw R.ArgumentError["new"]();
      }
      size = this.__size__();
      if (n > size) {
        n = size;
      }
      ary = this.to_native_clone();
      idx = -1;
      while (++idx < n) {
        ridx = idx + R.rand(size - idx);
        tmp = ary[idx];
        ary[idx] = ary[ridx];
        ary[ridx] = tmp;
      }
      return new R.Array(ary).slice(0, n);
    };

    Array.prototype.reject_bang = function(block) {
      var ary;
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('reject_bang');
      }
      ary = this.reject(block);
      if (ary.__size__() === this.__size__()) {
        return null;
      } else {
        return this.replace(ary);
      }
    };

    Array.prototype.replace = function(val) {
      this.__ensure_args_length(arguments, 1);
      this.__native__ = val.to_ary != null ? val.to_ary().to_native().slice(0) : val.slice(0);
      return this;
    };

    Array.prototype.reverse = function() {
      return this.dup().tap(function(w) {
        return w.reverse_bang();
      });
    };

    Array.prototype.reverse_bang = function() {
      this.replace(this.__native__.reverse());
      return this;
    };

    Array.prototype.reverse_each = function(block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('reverse_each');
      }
      _arr.reverse_each(this.__native__, block);
      return this;
    };

    Array.prototype.rotate = function(cnt) {
      var ary, idx, sliced;
      if (cnt === void 0) {
        cnt = 1;
      }
      cnt = RCoerce.to_int_native(cnt);
      ary = this.dup();
      if (this.__size__() === 1) {
        return ary;
      }
      if (this.empty()) {
        return new R.Array([]);
      }
      idx = cnt % ary.__size__();
      sliced = ary.slice(R.rng(0, idx, true));
      return ary.slice(R.rng(idx, -1)).concat(sliced);
    };

    Array.prototype.rotate_bang = function(cnt) {
      if (cnt === void 0) {
        cnt = 1;
        return this.replace(this.rotate(cnt));
      } else {
        cnt = RCoerce.to_int_native(cnt);
        if (cnt === 0 || cnt === 1) {
          return this;
        }
        return this.replace(this.rotate(cnt));
      }
    };

    Array.prototype.select_bang = function(block) {
      var ary;
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('select_bang');
      }
      ary = this.select(block);
      if (ary.__size__() === this.__size__()) {
        return null;
      } else {
        return this.replace(ary);
      }
    };

    Array.prototype.shift = function(n) {
      var el, ret;
      if (arguments.length > 1) {
        throw R.ArgumentError["new"]();
      }
      if (n === void 0) {
        el = this.__native__[0];
        this.replace(this.__native__.slice(1));
        return el;
      } else {
        n = RCoerce.to_int_native(n);
        if (n < 0) {
          throw R.ArgumentError["new"]();
        }
        ret = this.first(n);
        this.replace(this.__native__.slice(n));
        return ret;
      }
    };

    Array.prototype.shuffle = function() {
      return this.dup().tap(function(ary) {
        return ary.shuffle_bang();
      });
    };

    Array.prototype.shuffle_bang = function() {
      var arr, idx, rnd, size, tmp;
      size = this.__size__();
      arr = this.__native__;
      idx = -1;
      while (++idx < size) {
        rnd = idx + R.rand(size - idx);
        tmp = arr[idx];
        arr[idx] = arr[rnd];
        arr[rnd] = tmp;
      }
      return this;
    };

    Array.prototype.size = function() {
      return R(this.__native__.length);
    };

    Array.prototype.__size__ = function() {
      return this.__native__.length;
    };

    Array.prototype.slice = function(idx, length) {
      var range, range_end, range_lenth, range_start, size;
      if (idx === null) {
        throw new R.TypeError["new"]();
      }
      size = this.__size__();
      if ((idx != null ? idx.is_range : void 0) != null) {
        range = idx;
        range_start = RCoerce.to_int_native(range.begin());
        range_end = RCoerce.to_int_native(range.end());
        if (range_start < 0) {
          range_start = range_start + size;
        }
        if (range_end < 0) {
          range_end = range_end + size;
        }
        if (!range.exclude_end()) {
          range_end = range_end + 1;
        }
        range_lenth = range_end - range_start;
        if (range_start > size || range_start < 0) {
          return null;
        }
        return new R.Array(this.__native__.slice(range_start, range_end));
      } else {
        idx = RCoerce.to_int_native(idx);
      }
      if (idx < 0) {
        idx = size + idx;
      }
      if (length === void 0) {
        if (idx < 0 || idx >= size) {
          return null;
        }
        return this.at(idx);
      } else {
        length = RCoerce.to_int_native(length);
        if (idx < 0 || idx > size || length < 0) {
          return null;
        }
        return new R.Array(this.__native__.slice(idx, length + idx));
      }
    };

    Array.prototype.slice_bang = function(idx, length) {
      var ary, range, rng_end, rng_length, rng_start, size;
      if (idx === null) {
        throw new R.TypeError["new"]();
      }
      ary = null;
      size = this.__size__();
      if (idx.is_range != null) {
        range = idx;
        ary = this.slice(range);
        rng_start = RCoerce.to_int_native(range.begin());
        rng_end = RCoerce.to_int_native(range.end());
        if (rng_start < 0) {
          rng_start = rng_start + size;
        }
        if (rng_end < 0) {
          rng_end = rng_end + size;
        } else if (rng_end >= size) {
          rng_end >= size;
        }
        rng_length = rng_end - rng_start;
        if (!range.exclude_end()) {
          rng_length = rng_length + 1;
        }
        if (rng_start < size && rng_start >= 0 && rng_end <= size && rng_end >= 0 && rng_length > 0) {
          this.__delete_range(rng_start, rng_length);
        }
      } else if (length !== void 0) {
        idx = RCoerce.to_int_native(idx);
        length = RCoerce.to_int_native(length);
        if (idx > size) {
          return null;
        }
        if (length === 0) {
          return new R.Array([]);
        }
        ary = this.slice(idx, length);
        this.__delete_range(idx, length);
      } else {
        idx = RCoerce.to_int_native(idx);
        ary = this.delete_at(idx);
      }
      return ary;
    };

    Array.prototype.__delete_range = function(start, length) {
      var new_ary, size;
      size = this.__size__();
      if (start > size || start < 0) {
        return null;
      }
      if (size < (start + length)) {
        new_ary = new R.Array([]);
      } else {
        new_ary = this.slice(0, start).concat(this.slice(start + length, size) || []);
      }
      if (new_ary.__size__() !== this.__size__()) {
        return this.replace(new_ary);
      }
    };

    Array.prototype.sort_bang = function(block) {
      return this.replace(this.sort(block));
    };

    Array.prototype.sort_by_bang = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('sort_by_bang');
      }
      return this.replace(this.sort_by(block));
    };

    Array.prototype.transpose = function() {
      var max, out;
      if (this.empty()) {
        return new R.Array([]);
      }
      out = new R.Array([]);
      max = null;
      this.each(function(ary) {
        var entry, idx, len, _results;
        ary = RCoerce.to_ary(ary);
        max || (max = ary.size());
        if (!ary.size().equals(max)) {
          throw R.IndexError["new"]();
        }
        idx = -1;
        len = ary.__size__();
        _results = [];
        while (++idx < len) {
          if (!out.at(idx)) {
            out.append(new R.Array([]));
          }
          entry = out.at(idx);
          _results.push(entry.append(ary.at(idx)));
        }
        return _results;
      });
      return out;
    };

    Array.prototype.uniq = function() {
      var arr;
      arr = new R.Array([]);
      this.each(function(el) {
        if (!arr.include(el)) {
          return arr.push(el);
        }
      });
      return arr;
    };

    Array.prototype.uniq_bang = function(block) {
      var ary;
      ary = this.uniq();
      if (ary.__size__() === this.__size__()) {
        return null;
      } else {
        return this.replace(ary);
      }
    };

    Array.prototype.unshift = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.replace(args.concat(this.__native__));
    };

    Array.prototype.union = function(other) {
      return this.plus(other).uniq();
    };

    Array.prototype.to_a = function() {
      return this.dup();
    };

    Array.prototype.to_enum = function() {
      var args, iter;
      iter = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (iter == null) {
        iter = "each";
      }
      return new R.Enumerator(this, iter, args);
    };

    Array.prototype.to_ary = function() {
      return this;
    };

    Array.prototype.values_at = function() {
      var args, ary, idx;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      ary = (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
          idx = args[_j];
          _results.push(this.at(RCoerce.to_int_native(idx)) || null);
        }
        return _results;
      }).call(this);
      return new R.Array(ary);
    };

    Array.__add_default_aliases__(Array.prototype);

    Array.prototype.map_bang = Array.prototype.collect_bang;

    Array.prototype.index = Array.prototype.find_index;

    Array.prototype.each_for = Array.prototype.each;

    Array.prototype['|'] = Array.prototype.union;

    Array.prototype.to_s = Array.prototype.inspect;

    Array.prototype.intersection = Array.prototype['&'];

    Array.prototype.deleteAt = Array.prototype.delete_at;

    Array.prototype.deleteIf = Array.prototype.delete_if;

    Array.prototype.dropWhile = Array.prototype.drop_while;

    Array.prototype.eachIndex = Array.prototype.each_index;

    Array.prototype.equalValue = Array.prototype.equal_value;

    Array.prototype.findIndex = Array.prototype.find_index;

    Array.prototype.intersection = Array.prototype.intersection;

    Array.prototype.keepIf = Array.prototype.keep_if;

    Array.prototype.reverse_each = Array.prototype.reverse_each;

    Array.prototype.sortBy = Array.prototype.sort_by;

    Array.prototype.takeWhile = Array.prototype.take_while;

    Array.prototype.toA = Array.prototype.to_a;

    Array.prototype.toAry = Array.prototype.to_ary;

    Array.prototype.toS = Array.prototype.to_s;

    Array.prototype.tryConvert = Array.prototype.try_convert;

    Array.prototype.valuesAt = Array.prototype.values_at;

    Array.prototype.__native_array_with__ = function(size, obj) {
      var ary, idx;
      ary = nativeArray(RCoerce.to_int_native(size));
      idx = -1;
      while (++idx < size) {
        ary[idx] = obj;
      }
      return ary;
    };

    return Array;

  })(RubyJS.Object);

  RArray = R.Array = RubyJS.Array;

  R._arr = _arr;

  RubyJS.Hash = (function(_super) {

    __extends(Hash, _super);

    Hash.include(R.Enumerable);

    Hash["new"] = function() {
      return new R.Hash();
    };

    function Hash(hsh, default_value) {
      this.__native__ = hsh;
      this.__default__ = default_value;
    }

    Hash.prototype.assoc = function(needle) {
      var arr, k, v, _ref1, _ref2;
      needle = R(needle);
      arr = [];
      if (needle.rubyjs != null) {
        _ref1 = this.__native__;
        for (k in _ref1) {
          if (!__hasProp.call(_ref1, k)) continue;
          v = _ref1[k];
          if (needle.equals(k)) {
            return new R.Array([k, v]);
          }
        }
      } else {
        _ref2 = this.__native__;
        for (k in _ref2) {
          if (!__hasProp.call(_ref2, k)) continue;
          v = _ref2[k];
          if (needle === k) {
            return new R.Array([k, v]);
          }
        }
      }
      return null;
    };

    Hash.prototype.clear = function() {
      this.__native__ = {};
      return this;
    };

    Hash.prototype["default"] = function(key) {
      if (this.__default__) {
        if (this.__default__.call != null) {
          if (key !== void 0) {
            return this.__default__(this, key);
          }
        } else {
          return this.__default__;
        }
      } else {
        return null;
      }
    };

    Hash.prototype.default_proc = function() {
      var _ref1;
      if (((_ref1 = this.__default__) != null ? _ref1.call : void 0) != null) {
        return this.__default__;
      } else {
        return null;
      }
    };

    Hash.prototype["delete"] = function(key, block) {
      var value;
      if (this.has_key(key)) {
        value = this.get(key);
        delete this.__native__[key];
        return value;
      } else {
        if ((block != null ? block.call : void 0) != null) {
          return block(key);
        } else {
          return null;
        }
      }
    };

    Hash.prototype.delete_if = function(block) {
      var k, v, _ref1;
      if ((block != null ? block.call : void 0) != null) {
        _ref1 = this.__native__;
        for (k in _ref1) {
          if (!__hasProp.call(_ref1, k)) continue;
          v = _ref1[k];
          if (block(k, v)) {
            delete this.__native__[k];
          }
        }
        return this;
      } else {
        return this.to_enum('delete_if');
      }
    };

    Hash.prototype.each = function(block) {
      var k, v, _ref1;
      if ((block != null ? block.call : void 0) != null) {
        _ref1 = this.__native__;
        for (k in _ref1) {
          if (!__hasProp.call(_ref1, k)) continue;
          v = _ref1[k];
          block(k, v);
        }
        return this;
      } else {
        return this.to_enum('each');
      }
    };

    Hash.prototype.each_pair = Hash.prototype.each;

    Hash.prototype.each_key = function(block) {
      var k, v, _ref1;
      if ((block != null ? block.call : void 0) != null) {
        _ref1 = this.__native__;
        for (k in _ref1) {
          if (!__hasProp.call(_ref1, k)) continue;
          v = _ref1[k];
          block(k);
        }
        return this;
      } else {
        return this.to_enum('each_key');
      }
    };

    Hash.prototype.each_value = function(block) {
      var k, v, _ref1;
      if ((block != null ? block.call : void 0) != null) {
        _ref1 = this.__native__;
        for (k in _ref1) {
          if (!__hasProp.call(_ref1, k)) continue;
          v = _ref1[k];
          block(v);
        }
        return this;
      } else {
        return this.to_enum('each_value');
      }
    };

    Hash.prototype.empty = function() {
      var k, v, _ref1;
      _ref1 = this.__native__;
      for (k in _ref1) {
        if (!__hasProp.call(_ref1, k)) continue;
        v = _ref1[k];
        return false;
      }
      return true;
    };

    Hash.prototype.eql = function(other) {
      var k, v, _ref1;
      other = (typeof other.to_native === "function" ? other.to_native() : void 0) || other;
      _ref1 = this.__native__;
      for (k in _ref1) {
        if (!__hasProp.call(_ref1, k)) continue;
        v = _ref1[k];
        if (k in other) {
          if (!R.is_eql(other[k], v)) {
            return false;
          }
        } else {
          return false;
        }
      }
      return true;
    };

    Hash.prototype.fetch = function(key, default_value) {
      var _ref1;
      if (arguments.length === 0) {
        throw R.ArgumentError["new"]();
      }
      if (this.has_key(key)) {
        return this.get(key);
      } else if (((default_value != null ? default_value.call : void 0) != null) || (((_ref1 = arguments[2]) != null ? _ref1.call : void 0) != null)) {
        return (arguments[2] || default_value)(key);
      } else if (default_value !== void 0) {
        return default_value;
      } else {
        throw R.KeyError["new"]();
      }
    };

    Hash.prototype.get = function(key) {
      if ((this.__default__ != null) && !this.has_key(key)) {
        return this["default"](key);
      } else {
        return this.__native__[key];
      }
    };

    Hash.prototype.has_value = function(val) {
      var k, v, _ref1, _ref2;
      val = R(val);
      if (val.rubyjs != null) {
        _ref1 = this.__native__;
        for (k in _ref1) {
          if (!__hasProp.call(_ref1, k)) continue;
          v = _ref1[k];
          if (val.equals(v)) {
            return true;
          }
        }
      } else {
        _ref2 = this.__native__;
        for (k in _ref2) {
          if (!__hasProp.call(_ref2, k)) continue;
          v = _ref2[k];
          if (v === val) {
            return true;
          }
        }
      }
      return false;
    };

    Hash.prototype.has_key = function(key) {
      return key in this.__native__;
    };

    Hash.prototype.include = Hash.prototype.has_key;

    Hash.prototype.member = Hash.prototype.has_key;

    Hash.prototype.keep_if = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('keep_if');
      }
      this.reject_bang(block);
      return this;
    };

    Hash.prototype.key = function(value) {
      var k, v, _ref1, _ref2;
      if (value.rubyjs != null) {
        _ref1 = this.__native__;
        for (k in _ref1) {
          if (!__hasProp.call(_ref1, k)) continue;
          v = _ref1[k];
          if (value.equals(v)) {
            return k;
          }
        }
      } else {
        _ref2 = this.__native__;
        for (k in _ref2) {
          if (!__hasProp.call(_ref2, k)) continue;
          v = _ref2[k];
          if (v.valueOf() === value) {
            return k;
          }
        }
      }
      return null;
    };

    Hash.prototype.index = Hash.prototype.key;

    Hash.prototype.invert = function() {
      var hsh, k, v, _ref1;
      hsh = {};
      _ref1 = this.__native__;
      for (k in _ref1) {
        if (!__hasProp.call(_ref1, k)) continue;
        v = _ref1[k];
        hsh[v] = k;
      }
      return new R.Hash(hsh);
    };

    Hash.prototype.keys = function() {
      var arr, k, v;
      arr = (function() {
        var _ref1, _results;
        _ref1 = this.__native__;
        _results = [];
        for (k in _ref1) {
          if (!__hasProp.call(_ref1, k)) continue;
          v = _ref1[k];
          _results.push(k);
        }
        return _results;
      }).call(this);
      return new R.Array(arr);
    };

    Hash.prototype.merge = function(other, block) {
      var hsh, k, v, _ref1;
      hsh = {};
      if (other.rubyjs != null) {
        other = other.__native__;
      }
      _ref1 = this.__native__;
      for (k in _ref1) {
        if (!__hasProp.call(_ref1, k)) continue;
        v = _ref1[k];
        hsh[k] = v;
      }
      for (k in other) {
        if (!__hasProp.call(other, k)) continue;
        v = other[k];
        if (((block != null ? block.call : void 0) != null) && k in hsh) {
          hsh[k] = block(k, hsh[k], v);
        } else {
          hsh[k] = v;
        }
      }
      return new R.Hash(hsh);
    };

    Hash.prototype.merge_bang = function(other, block) {
      var k, v, _ref1;
      if (other.rubyjs != null) {
        other = other.__native__;
      }
      _ref1 = this.__native__;
      for (k in _ref1) {
        if (!__hasProp.call(_ref1, k)) continue;
        v = _ref1[k];
        this.__native__[k] = v;
      }
      for (k in other) {
        if (!__hasProp.call(other, k)) continue;
        v = other[k];
        if (((block != null ? block.call : void 0) != null) && k in this.__native__) {
          this.__native__[k] = block(k, this.__native__[k], v);
        } else {
          this.__native__[k] = v;
        }
      }
      return this;
    };

    Hash.prototype.rassoc = function(needle) {
      var arr, k, v, _ref1, _ref2;
      needle = R(needle);
      arr = [];
      if (needle.rubyjs != null) {
        _ref1 = this.__native__;
        for (k in _ref1) {
          if (!__hasProp.call(_ref1, k)) continue;
          v = _ref1[k];
          if (needle.equals(v)) {
            return new R.Array([k, v]);
          }
        }
      } else {
        _ref2 = this.__native__;
        for (k in _ref2) {
          if (!__hasProp.call(_ref2, k)) continue;
          v = _ref2[k];
          if (needle === v) {
            return new R.Array([k, v]);
          }
        }
      }
      return null;
    };

    Hash.prototype.reject = function(block) {
      var dup, k, v, _ref1;
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('reject');
      }
      dup = {};
      _ref1 = this.__native__;
      for (k in _ref1) {
        if (!__hasProp.call(_ref1, k)) continue;
        v = _ref1[k];
        if (!block(k, v)) {
          dup[k] = v;
        }
      }
      return new R.Hash(dup);
    };

    Hash.prototype.reject_bang = function(block) {
      var changed, k, v, _ref1;
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('reject_bang');
      }
      changed = false;
      _ref1 = this.__native__;
      for (k in _ref1) {
        if (!__hasProp.call(_ref1, k)) continue;
        v = _ref1[k];
        if (!block(k, v)) {
          delete this.__native__[k];
          changed = true;
        }
      }
      if (changed) {
        return this;
      } else {
        return null;
      }
    };

    Hash.prototype.select = function(block) {
      var dup, k, v, _ref1;
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('select');
      }
      dup = {};
      _ref1 = this.__native__;
      for (k in _ref1) {
        if (!__hasProp.call(_ref1, k)) continue;
        v = _ref1[k];
        if (block(k, v)) {
          dup[k] = v;
        }
      }
      return new R.Hash(dup);
    };

    Hash.prototype.select_bang = function(block) {
      var changed, k, v, _ref1;
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('select_bang');
      }
      changed = false;
      _ref1 = this.__native__;
      for (k in _ref1) {
        if (!__hasProp.call(_ref1, k)) continue;
        v = _ref1[k];
        if (block(k, v)) {
          delete this.__native__[k];
          changed = true;
        }
      }
      if (changed) {
        return this;
      } else {
        return null;
      }
    };

    Hash.prototype.set = function(key, value) {
      return this.__native__[key] = value;
    };

    Hash.prototype.flatten = function(recursion) {
      if (recursion == null) {
        recursion = 1;
      }
      recursion = RCoerce.to_int_native(recursion);
      return this.to_a().flatten(recursion);
    };

    Hash.prototype.sort = function(block) {
      return this.to_a().sort(block);
    };

    Hash.prototype.store = Hash.prototype.set;

    Hash.prototype.size = function() {
      var counter, k, v, _ref1;
      counter = 0;
      _ref1 = this.__native__;
      for (k in _ref1) {
        if (!__hasProp.call(_ref1, k)) continue;
        v = _ref1[k];
        counter += 1;
      }
      return new R.Fixnum(counter);
    };

    Hash.prototype.to_a = function() {
      var arr, k, v;
      arr = (function() {
        var _ref1, _results;
        _ref1 = this.__native__;
        _results = [];
        for (k in _ref1) {
          if (!__hasProp.call(_ref1, k)) continue;
          v = _ref1[k];
          _results.push([k, v]);
        }
        return _results;
      }).call(this);
      return new R.Array(arr);
    };

    Hash.prototype.to_hash = function() {
      return this;
    };

    Hash.prototype.to_h = Hash.prototype.to_hash;

    Hash.prototype.to_native = function() {
      return this.__native__;
    };

    Hash.prototype.update = Hash.prototype.merge_bang;

    Hash.prototype.values = function() {
      var arr, k, v;
      arr = (function() {
        var _ref1, _results;
        _ref1 = this.__native__;
        _results = [];
        for (k in _ref1) {
          if (!__hasProp.call(_ref1, k)) continue;
          v = _ref1[k];
          _results.push(v);
        }
        return _results;
      }).call(this);
      return new R.Array(arr);
    };

    Hash.prototype.values_at = function(keys) {
      var arr, k;
      arr = (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = arguments.length; _j < _len1; _j++) {
          k = arguments[_j];
          _results.push(this.get(k));
        }
        return _results;
      }).apply(this, arguments);
      return R(arr);
    };

    return Hash;

  })(RubyJS.Object);

  R.hashify = function(obj, default_value) {
    return new R.Hash(obj, default_value);
  };

  R.h = R.hashify;

  RubyJS.Range = (function(_super) {

    __extends(Range, _super);

    Range.include(R.Enumerable);

    Range["new"] = function(start, end, exclusive) {
      if (exclusive == null) {
        exclusive = false;
      }
      return new R.Range(start, end, exclusive);
    };

    function Range(start, end, exclusive) {
      this.exclusive = exclusive != null ? exclusive : false;
      this.__start__ = this.box(start);
      this.__end__ = this.box(end);
      if (!((this.__start__.is_fixnum != null) && (this.__end__.is_fixnum != null))) {
        try {
          if (this.__start__['<=>'](this.__end__) === null) {
            throw R.ArgumentError["new"]();
          }
        } catch (err) {
          throw R.ArgumentError["new"]();
        }
      }
      this.comparison = this.exclusive ? '<' : '<=';
    }

    Range.prototype.is_range = function() {
      return true;
    };

    Range.prototype.iterator = function() {
      var arr;
      arr = [];
      this.each(function(e) {
        return arr.push(e);
      });
      return arr;
    };

    Range.prototype['=='] = function(other) {
      if (!(other instanceof R.Range)) {
        return false;
      }
      return this.__end__['=='](other.end()) && this.__start__['=='](other.start()) && this.exclusive === other.exclude_end();
    };

    Range.prototype.equals = Range.prototype['=='];

    Range.prototype.begin = function(obj) {
      return this.__start__;
    };

    Range.prototype.cover = function(obj) {
      if (arguments.length !== 1) {
        throw R.ArgumentError["new"]();
      }
      obj = obj;
      if (obj === null) {
        return false;
      }
      return this.equal_case(obj);
    };

    Range.prototype['==='] = function(other) {
      var e, s;
      other = R(other);
      s = other['<=>'](this.__start__);
      e = other['<=>'](this.__end__);
      if (s === null && e === null) {
        return false;
      }
      s = -s;
      e = -e;
      return s <= 0 && (this.exclusive ? e > 0 : e >= 0);
    };

    Range.prototype.each = function(block) {
      var iterator;
      if (!(block && (block.call != null))) {
        return this.to_enum('each');
      }
      if (this.begin().succ == null) {
        throw R.TypeError["new"]("can't iterate from " + (this.begin()));
      }
      iterator = this.__start__.dup();
      while (iterator[this.comparison](this.__end__)) {
        block(iterator);
        iterator = iterator.succ();
      }
      return this;
    };

    Range.prototype.end = function() {
      return this.__end__;
    };

    Range.prototype.exclude_end = function() {
      return this.exclusive;
    };

    Range.prototype.first = function(n) {
      return this.begin();
    };

    Range.prototype.inspect = function() {
      var sep;
      sep = this.exclude_end() ? "..." : "..";
      return "" + (this.start().inspect()) + sep + (this.end().inspect());
    };

    Range.prototype.min = function(block) {
      var b, e;
      if ((block != null ? block.call : void 0) != null) {
        return R.Enumerable.prototype.min.call(this, block);
      }
      b = this.begin();
      e = this.end();
      if (e['<'](b) || (this.exclusive && e.equals(b))) {
        return null;
      }
      if (b.is_float != null) {
        return b;
      }
      return R.Enumerable.prototype.min.call(this);
    };

    Range.prototype.max = function(block) {
      var b, e;
      if ((block != null ? block.call : void 0) != null) {
        return R.Enumerable.prototype.max.call(this, block);
      }
      b = this.begin();
      e = this.end();
      if (e['<'](b) || (this.exclusive && e.equals(b))) {
        return null;
      }
      if ((e.is_float != null) || ((e.is_float != null) && !this.exclusive)) {
        return e;
      }
      return R.Enumerable.prototype.max.call(this);
    };

    Range.prototype.start = function() {
      return this.__start__;
    };

    Range.prototype.step = function(step_size, block) {
      var cmp, cnt, first, last;
      if (step_size == null) {
        step_size = 1;
      }
      if (arguments.length === 1 && (step_size.call != null)) {
        block = step_size;
        step_size = 1;
      }
      if (!(block && (block.call != null))) {
        return this.to_enum('step', step_size);
      }
      step_size = R(step_size);
      first = this.begin();
      last = this.end();
      if (((step_size != null ? step_size.is_float : void 0) != null) || (first.is_float != null) || (last.is_float != null)) {
        step_size = step_size.to_f();
        first = first.to_f();
        last = last.to_f();
      } else {
        step_size = RCoerce.to_int_native(step_size);
      }
      if (step_size <= 0) {
        if (step_size < 0) {
          throw R.ArgumentError["new"]();
        }
        throw R.ArgumentError["new"]();
      }
      cnt = first;
      cmp = this.exclude_end() ? '<' : '<=';
      if (first.is_float != null) {
        while (cnt[cmp](last)) {
          block(cnt);
          cnt = cnt.plus(step_size);
        }
      } else if (first.is_fixnum != null) {
        while (cnt[cmp](last)) {
          block(cnt);
          cnt = cnt.plus(step_size);
        }
      } else {
        cnt = 0;
        this.each(function(o) {
          if (cnt % step_size === 0) {
            block(R(o));
          }
          return cnt += 1;
        });
      }
      return this;
    };

    Range.prototype.to_a = function() {
      if ((this.__end__.is_float != null) && (this.__start__.is_float != null)) {
        throw R.TypeError["new"]();
      }
      return R.Enumerable.prototype.to_a.apply(this);
    };

    Range.prototype.to_s = Range.prototype.inspect;

    Range.__add_default_aliases__(Range.prototype);

    Range.prototype.eql = Range.prototype['=='];

    Range.prototype.include = Range.prototype['==='];

    Range.prototype.last = Range.prototype.end;

    Range.prototype.member = Range.prototype.include;

    Range.prototype.excludeEnd = Range.prototype.exclude_end;

    return Range;

  })(RubyJS.Object);

  RubyJS.MatchData = (function(_super) {

    __extends(MatchData, _super);

    function MatchData(__native__, opts) {
      var i, m, _j, _len1, _ref1;
      this.__native__ = __native__;
      if (opts == null) {
        opts = {};
      }
      _ref1 = this.__native__;
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        m = _ref1[i];
        this[i] = m;
      }
      this.__offset__ = opts.offset || 0;
      this.__source__ = opts.string;
      this.__regexp__ = opts.regexp;
    }

    MatchData.prototype.is_match_data = function() {
      return true;
    };

    MatchData.prototype['=='] = function(other) {
      if (!(other.is_match_data != null)) {
        return false;
      }
      return this.regexp()['=='](other.regexp()) && this.string()['=='](other.string()) && this.__offset__ === other.__offset__;
    };

    MatchData.prototype.begin = function(offset) {
      this.__ensure_args_length(1);
      return R(this.__source__.slice(this.__offset__).indexOf(this.__native__[offset]) + this.__offset__);
    };

    MatchData.prototype.captures = function() {
      return R(this.__native__.slice(1));
    };

    MatchData.prototype.end = function(offset) {
      this.__ensure_args_length(1);
      return R(this.__source__.slice(this.__offset__).indexOf(this.__native__[offset]) + this.__offset__ + this.__native__[offset].length);
    };

    MatchData.prototype.eql = function(other) {
      return this['=='](other);
    };

    MatchData.prototype.get = function() {
      var args, arr;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      arr = this.to_a();
      return arr.get.apply(arr, arguments);
    };

    MatchData.prototype.inspect = function() {
      var results;
      results = R(["\"" + this[0] + "\""]);
      results.concat(this.captures().each_with_index().map(function(w, i) {
        return "" + (i + 1) + ":\"" + w + "\"";
      }));
      return new R.String("#<MatchData " + (results.join(" ")) + ">");
    };

    MatchData.prototype.length = function() {
      return R(this.__native__.length);
    };

    MatchData.prototype.offset = function(offset) {
      var b;
      b = this.begin(offset);
      return R([b.to_native(), b + this.__native__[offset].length]);
    };

    MatchData.prototype.post_match = function() {
      return this.__source__.slice(this.end(0));
    };

    MatchData.prototype.pre_match = function() {
      return this.__source__.slice(0, this.begin(0));
    };

    MatchData.prototype.regexp = function() {
      return R(this.__regexp__);
    };

    MatchData.prototype.size = function() {
      return this.length();
    };

    MatchData.prototype.string = function() {
      return R(this.__source__);
    };

    MatchData.prototype.to_a = function() {
      return R(this.__native__);
    };

    MatchData.prototype.to_s = function() {
      return R(this.__native__[0]);
    };

    MatchData.prototype.values_at = function() {
      var arr, indices;
      indices = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      arr = this.to_a();
      return arr.values_at.apply(arr, indices);
    };

    MatchData.prototype.names = function() {
      throw R.NotSupportedError["new"]();
    };

    MatchData.prototype.postMatch = MatchData.prototype.post_match;

    MatchData.prototype.preMatch = MatchData.prototype.pre_match;

    MatchData.prototype.valuesAt = MatchData.prototype.values_at;

    return MatchData;

  })(RubyJS.Object);

  nativeString = root.String;

  RubyJS.String = (function(_super) {

    __extends(String, _super);

    String.include(R.Comparable);

    String.fromCharCode = function(obj) {
      return nativeString.fromCharCode(obj);
    };

    String["new"] = function(str) {
      if (str == null) {
        str = '';
      }
      return new R.String(str);
    };

    function String(primitive) {
      if (primitive == null) {
        primitive = "";
      }
      if (typeof primitive !== 'string') {
        primitive = primitive.valueOf();
      }
      this.replace(primitive);
    }

    String.isString = function(obj) {
      if (obj == null) {
        return false;
      }
      if (typeof obj === 'string') {
        return true;
      }
      if (typeof obj !== 'object') {
        return false;
      }
      if (obj.is_string != null) {
        return true;
      }
      return _toString_.call(obj) === '[object String]';
    };

    String.try_convert = function(obj) {
      if (!(this.isString(obj) || (obj.to_str != null))) {
        return null;
      }
      if (obj.to_str != null) {
        obj = obj.to_str();
        if (obj === null || obj === void 0) {
          return null;
        }
        if (obj.is_string == null) {
          throw R.TypeError["new"]();
        }
        return obj;
      } else {
        return this["new"](obj);
      }
    };

    String.string_native = function(obj) {
      if (typeof obj === 'string') {
        return obj;
      }
      obj = R(obj);
      if (obj.to_str != null) {
        return obj.to_str().to_native();
      } else {
        return null;
      }
    };

    String.prototype.is_string = function() {
      return true;
    };

    String.prototype.to_native = function() {
      return this.__native__;
    };

    String.prototype.valueOf = function() {
      return this.to_native();
    };

    String.prototype.toString = function() {
      return this.to_native();
    };

    String.prototype.unbox = function() {
      return this.__native__;
    };

    String.prototype.initialize_copy = function() {};

    String.prototype.clone = function() {
      return new this.constructor(this.to_native() + "");
    };

    String.prototype['%'] = function(num) {
      throw R.NotImplementedError["new"]();
    };

    String.prototype['*'] = function(num) {
      num = RCoerce.to_int_native(num);
      return new RString(_str.multiply(this.__native__, num));
    };

    String.prototype['+'] = function(other) {
      other = RCoerce.to_str_native(other);
      return new R.String(this.to_native() + other);
    };

    String.prototype['<=>'] = function(other) {
      other = R(other);
      if (other.to_str == null) {
        return null;
      }
      if (other['<=>'] == null) {
        return null;
      }
      if (other.is_string != null) {
        other = other.to_native();
        if (this.to_native() === other) {
          return 0;
        } else if (this.to_native() < other) {
          return -1;
        } else {
          return 1;
        }
      } else {
        return -other['<=>'](this);
      }
    };

    String.prototype['=='] = function(other) {
      if (other.is_string != null) {
        return this.to_native() === other.to_native();
      } else if (String.isString(other)) {
        return this.to_native() === other;
      } else if (other.to_str != null) {
        return other['=='](this.to_native());
      } else {
        return false;
      }
    };

    String.prototype['<<'] = function(other) {
      other = this.box(other);
      if (other.is_integer != null) {
        if (other.lt(0)) {
          throw new Error("RangeError");
        }
        other = other.chr();
      }
      if ((other != null ? other.to_str : void 0) == null) {
        throw R.TypeError["new"]();
      }
      return this.replace(this.to_native() + other.to_str().to_native());
    };

    String.prototype['=~'] = function(pattern, offset, block) {
      if (R(pattern).is_string != null) {
        throw R.TypeError["new"]();
      }
      return this.match(pattern, offset, block);
    };

    String.prototype.capitalize = function() {
      return new RString(_str.capitalize(this.__native__));
    };

    String.prototype.capitalize_bang = function() {
      var str;
      str = _str.capitalize(this.__native__);
      if (this.__native__ === str) {
        return null;
      } else {
        return this.replace(str);
      }
    };

    String.prototype.casecmp = function(other) {
      var _base;
      other = typeof (_base = R(other)).to_str === "function" ? _base.to_str() : void 0;
      if (!other) {
        throw R.TypeError["new"]();
      }
      return this.downcase().cmp(other.downcase());
    };

    String.prototype.center = function(length, padString) {
      if (padString == null) {
        padString = ' ';
      }
      length = RCoerce.to_int_native(length);
      padString = RCoerce.to_str_native(padString);
      return new RString(_str.center(this.__native__, length, padString));
    };

    String.prototype.chars = function(block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('chars');
      }
      _str.chars(this.__native__, block);
      return this;
    };

    String.prototype.chomp = function(sep) {
      if (sep == null) {
        sep = null;
      }
      if (sep === null) {
        return this;
      } else {
        return new RString(_str.chomp(this.__native__, sep));
      }
    };

    String.prototype.chomp_bang = function(sep) {
      var str;
      if (sep == null) {
        sep = null;
      }
      if (str = _str.chomp(this.__native__, sep)) {
        return this.replace(str);
      } else {
        return null;
      }
    };

    String.prototype.chop = function() {
      return new RString(_str.chop(this.__native__));
    };

    String.prototype.chr = function() {
      var c;
      c = this.empty() ? "" : this.to_native()[0];
      return this.box(c);
    };

    String.prototype.clear = function() {
      return this.replace("");
    };

    String.prototype.count = function() {
      var args, el, i, _j, _len1;
      args = [this.__native__];
      for (i = _j = 0, _len1 = arguments.length; _j < _len1; i = ++_j) {
        el = arguments[i];
        args.push(RCoerce.to_str_native(el));
      }
      return new R.Fixnum(_str.count.apply(_str, args));
    };

    String.prototype["delete"] = function() {
      var args;
      args = arguments;
      return this.dup().tap(function(s) {
        return s.delete_bang.apply(s, args);
      });
    };

    String.prototype.delete_bang = function() {
      var args, el, i, str, _j, _len1;
      args = [this.__native__];
      for (i = _j = 0, _len1 = arguments.length; _j < _len1; i = ++_j) {
        el = arguments[i];
        args.push(RCoerce.to_str_native(el));
      }
      str = _str["delete"].apply(null, args);
      if (this.equals(str)) {
        return null;
      }
      return this.replace(str);
    };

    String.prototype.downcase = function() {
      return new RString(_str.downcase(this.__native__));
    };

    String.prototype.downcase_bang = function() {
      if (!this.__native__.match(/[A-Z]/)) {
        return null;
      }
      return this.replace(_str.downcase(this.__native__));
    };

    String.prototype.dump = function() {
      var escaped;
      escaped = this.to_native().replace(/[\f]/g, '\\f').replace(/["]/g, "\\\"").replace(/[\n]/g, '\\n').replace(/[\r]/g, '\\r').replace(/[\t]/g, '\\t');
      return R("\"" + escaped + "\"");
    };

    String.prototype.dup = function() {
      var dup;
      dup = this.clone();
      dup.initialize_copy(this);
      return dup;
    };

    String.prototype.each_char = String.prototype.chars;

    String.prototype.each_line = function() {
      var args, block, dup, lft, remainder, rgt, separator, str;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      block = this.__extract_block(args);
      if (!(block && (block.call != null))) {
        return this.to_enum('lines', args[0]);
      }
      if (args[0] === null) {
        block(this);
        return;
      }
      separator = R(args[0] === void 0 ? R['$/'] : args[0]);
      if (separator.to_str == null) {
        throw R.TypeError["new"]();
      }
      separator = separator.to_str();
      if (separator.length === 0) {
        separator = "\n\n";
      }
      lft = 0;
      rgt = null;
      dup = this.dup();
      while (rgt = dup.index(separator, lft)) {
        rgt = rgt.succ();
        str = dup.slice(lft, rgt.minus(lft));
        lft = rgt;
        block(str);
      }
      if (remainder = R(dup.to_native().slice(lft.to_native()))) {
        if (!remainder.empty()) {
          block(remainder);
        }
      }
      return this;
    };

    String.prototype.empty = function() {
      return _str.empty(this.__native__);
    };

    String.prototype.end_with = function() {
      var needles, neeldes;
      needles = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      needles = _arr.select(needles, function(s) {
        var _ref1;
        return ((_ref1 = R(s)) != null ? _ref1.to_str : void 0) != null;
      });
      neeldes = _arr.map(needles, _fn(RCoerce.to_str_native));
      return _str.end_with.apply(_str, [this.__native__].concat(__slice.call(needles)));
    };

    String.prototype.eql = function(other) {
      return this['<=>'](other) === 0;
    };

    String.prototype.get = function() {
      return this.slice.apply(this, arguments);
    };

    String.prototype.set = function(idx, other) {
      var chrs, index;
      idx = R(idx);
      other = RCoerce.to_str(other);
      index = null;
      if (idx.to_int != null) {
        index = idx.to_int().to_native();
        if (index < 0) {
          index += this.length;
        }
        if (index < 0 || index > this.length) {
          throw R.IndexError["new"]();
        }
      } else if (idx.to_str != null) {
        index = this.index(idx);
        if (!index) {
          throw R.IndexError["new"]();
        }
      }
      chrs = this.to_native().split("");
      chrs[index] = other;
      this.replace(chrs.join(''));
      return other;
    };

    String.prototype.gsub = function(pattern, replacement) {
      var gsubbed, pattern_lit;
      if (pattern === null) {
        throw R.TypeError["new"]();
      }
      pattern_lit = String.string_native(pattern);
      if (pattern_lit !== null) {
        pattern = new RegExp(R.Regexp.escape(pattern_lit), 'g');
      }
      if (!R.Regexp.isRegexp(pattern)) {
        throw R.TypeError["new"]();
      }
      if (!pattern.global) {
        throw "String#gsub: " + pattern + " has not set the global flag 'g'. " + pattern + "g";
      }
      replacement = RCoerce.to_str(replacement).to_native();
      gsubbed = this.to_native().replace(pattern, replacement);
      return new this.constructor(gsubbed);
    };

    String.prototype.include = function(other) {
      other = RCoerce.to_str_native(other);
      return _str.include(this.__native__, other);
    };

    String.prototype.index = function(needle, offset) {
      var val;
      needle = RCoerce.to_str_native(needle);
      if (offset != null) {
        offset = RCoerce.to_int_native(offset);
      }
      val = _str.index(this.__native__, needle, offset);
      if (val === null) {
        return null;
      } else {
        return new R.Fixnum(val);
      }
    };

    String.prototype.insert = function(idx, other) {
      var after, before, chrs, insert;
      idx = RCoerce.to_int(idx);
      other = RCoerce.to_str(other);
      idx = idx.to_native();
      if (idx < 0) {
        idx = this.length - Math.abs(idx) + 1;
      }
      if (idx < 0 || idx > this.length) {
        throw R.IndexError["new"]();
      }
      chrs = this.to_native().split("");
      before = chrs.slice(0, idx);
      insert = other.to_native().split("");
      after = chrs.slice(idx);
      return this.replace(before.concat(insert).concat(after).join(''));
    };

    String.prototype.inspect = function() {
      return this.dump();
    };

    String.prototype.lines = String.prototype.each_line;

    String.prototype.ljust = function(width, padString) {
      if (padString == null) {
        padString = " ";
      }
      width = RCoerce.to_int_native(width);
      padString = RCoerce.to_str_native(padString);
      return new RString(_str.ljust(this.__native__, width, padString));
    };

    String.prototype.lstrip = function() {
      return new RString(_str.lstrip(this.__native__));
    };

    String.prototype.lstrip_bang = function() {
      if (!this.to_native().match(/^[\s\n\t]+/)) {
        return null;
      }
      return this.replace(_str.lstrip(this.__native__));
    };

    String.prototype.match = function(pattern, offset, block) {
      return _str.match(this.__native__, pattern, offset, block);
    };

    String.prototype.partition = function(pattern) {
      pattern = RCoerce.to_str_native(pattern);
      return new RArray(_str.partition(this.__native__, pattern));
    };

    String.prototype.prepend = function(other) {
      other = RCoerce.to_str_native(other);
      return this.replace(other + this.to_native());
    };

    String.prototype.replace = function(val) {
      if (typeof val !== 'string') {
        val = R(val);
        if (val.to_str == null) {
          throw R.TypeError["new"]();
        }
        val = val.to_str().valueOf();
      }
      this.__native__ = val;
      this.length = val.length;
      return this;
    };

    String.prototype.reverse = function() {
      return new RString(_str.reverse(this.__native__));
    };

    String.prototype.reverse_bang = function() {
      return this.replace(_str.reverse(this.__native__));
    };

    String.prototype.rindex = function(needle, offset) {
      var ret, _ref1;
      if (offset === null) {
        throw R.TypeError["new"]('TypeError');
      }
      needle = R(needle);
      if (needle.to_str != null) {
        needle = needle.to_str();
      } else if (needle.is_regexp != null) {
        needle = needle;
      } else {
        throw R.TypeError["new"]('TypeError');
      }
      offset = (_ref1 = this.box(offset)) != null ? _ref1.to_int() : void 0;
      if (offset !== void 0) {
        if (offset.lt(0)) {
          offset = offset.plus(this.size());
        }
        if (offset.lt(0)) {
          return null;
        }
        if (needle.is_string != null) {
          offset = offset.plus(needle.size());
          ret = this.to_native().slice(0, offset).lastIndexOf(needle.to_native());
        } else {
          ret = this.__rindex_with_regexp__(needle, offset);
        }
      } else {
        if (needle.is_string != null) {
          ret = this.to_native().lastIndexOf(needle.to_native());
        } else {
          ret = this.__rindex_with_regexp__(needle);
        }
      }
      if (ret === -1) {
        return null;
      } else {
        return this.$Integer(ret);
      }
    };

    String.prototype.__rindex_with_regexp__ = function(needle, offset) {
      var idx, length, match, match_begin, ret;
      needle = needle.to_native();
      offset = this.box(offset);
      idx = 0;
      length = this.size();
      match_begin = needle.toString().match(/\/\^/) !== null;
      ret = -1;
      while (match = this.to_native().slice(idx).match(needle)) {
        if (offset && offset < (idx + match.index)) {
          break;
        }
        ret = idx;
        idx = idx + 1;
        if (match_begin || idx > length) {
          break;
        }
      }
      return ret;
    };

    String.prototype.rjust = function(width, padString) {
      if (padString == null) {
        padString = " ";
      }
      width = RCoerce.to_int_native(width);
      padString = RCoerce.to_str_native(padString);
      return new RString(_str.rjust(this.__native__, width, padString));
    };

    String.prototype.rpartition = function(pattern) {
      var a, b, c, idx, len, start;
      pattern = RCoerce.to_str(pattern).to_str();
      if (idx = this.rindex(pattern)) {
        start = idx + pattern.length;
        len = this.size() - start;
        a = this.slice(0, idx);
        b = pattern.dup();
        c = R(this.to_native().slice(start));
      }
      a || (a = R(""));
      b || (b = R(""));
      c || (c = this);
      return R([a, b, c]);
    };

    String.prototype.rstrip = function() {
      return this.dup().tap(function(s) {
        return s.rstrip_bang();
      });
    };

    String.prototype.rstrip_bang = function() {
      if (!this.to_native().match(/[\s\n\t]+$/)) {
        return null;
      }
      return this.replace(this.to_native().replace(/[\s\n\t]+$/g, ''));
    };

    String.prototype.scan = function(pattern, block) {
      var fin, index, m, match, match_arr, val;
      if (block == null) {
        block = null;
      }
      if (!R.Regexp.isRegexp(pattern)) {
        pattern = RCoerce.to_str_native(pattern);
        pattern = R.Regexp.quote(pattern);
      }
      index = 0;
      R['$~'] = null;
      match_arr = block !== null ? this : [];
      while (match = this.__native__.slice(index).match(pattern)) {
        fin = index + match.index + match[0].length;
        if (match[0].length === 0) {
          fin += 1;
        }
        R['$~'] = new R.MatchData(match, {
          offset: index,
          string: this.__native__
        });
        if (match.length > 1) {
          val = new R.Array((function() {
            var _j, _len1, _ref1, _results;
            _ref1 = match.slice(1, match.length);
            _results = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              m = _ref1[_j];
              _results.push(new R.String(m));
            }
            return _results;
          })());
        } else {
          val = new R.Array([new R.String(match[0])]);
        }
        if (block !== null) {
          block(val);
        } else {
          if (match.length === 1) {
            val = val.first();
          }
          match_arr.push(val);
        }
        index = fin;
        if (index > this.length) {
          break;
        }
      }
      if (block !== null) {
        return this;
      } else {
        return new R.Array(match_arr);
      }
    };

    String.prototype.size = function() {
      return this.$Integer(this.to_native().length);
    };

    String.prototype.slice = function(index, other) {
      var val;
      if (index === null) {
        throw R.TypeError["new"]();
      }
      index = R(index);
      if (other !== void 0) {
        if (index.is_regexp != null) {
          throw R.NotImplementedError["new"]();
        } else {
          index = RCoerce.to_int_native(index);
          other = RCoerce.to_int_native(other);
          val = _str.slice(this.__native__, index, other);
          if (val != null) {
            return new RString(val);
          } else {
            return null;
          }
        }
      }
      if (index.is_regexp != null) {
        throw R.NotImplementedError["new"]();
      } else if (index.is_string != null) {
        index = RCoerce.to_str_native(index);
      } else if (index.is_range != null) {

      } else {
        index = RCoerce.to_int_native(index);
      }
      val = _str.slice(this.__native__, index);
      if (val != null) {
        return new RString(val);
      } else {
        return null;
      }
    };

    String.prototype.split = function(pattern, limit) {
      var ret, str;
      if (pattern == null) {
        pattern = " ";
      }
      if (!R.Regexp.isRegexp(pattern)) {
        pattern = RCoerce.to_str(pattern).to_native();
      }
      ret = this.to_native().split(pattern);
      ret = R((function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = ret.length; _j < _len1; _j++) {
          str = ret[_j];
          _results.push(new this.constructor(str));
        }
        return _results;
      }).call(this));
      while (str = ret.last()) {
        if (!str.empty()) {
          break;
        }
        ret.pop();
      }
      if (pattern === ' ') {
        ret.delete_if(function(str) {
          return str.empty();
        });
      }
      return ret;
    };

    String.prototype.squeeze_bang = function() {
      throw new R.NotImplementedError();
    };

    String.prototype.squeeze = function() {
      var args, el, i, _j, _len1;
      args = [this.__native__];
      for (i = _j = 0, _len1 = arguments.length; _j < _len1; i = ++_j) {
        el = arguments[i];
        args.push(RCoerce.to_str_native(el));
      }
      return new RString(_str.squeeze.apply(_str, args));
    };

    String.prototype.start_with = function() {
      var needles, neeldes;
      needles = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      needles = _arr.select(needles, function(s) {
        var _ref1;
        return ((_ref1 = R(s)) != null ? _ref1.to_str : void 0) != null;
      });
      neeldes = _arr.map(needles, _fn(RCoerce.to_str_native));
      return _str.start_with.apply(_str, [this.__native__].concat(__slice.call(needles)));
    };

    String.prototype.strip = function() {
      return this.dup().tap(function(s) {
        return s.strip_bang();
      });
    };

    String.prototype.strip_bang = function() {
      var l, r;
      l = this.lstrip_bang();
      r = this.rstrip_bang();
      if (l === null && r === null) {
        return null;
      } else {
        return this;
      }
    };

    String.prototype.sub = function(pattern, replacement) {
      return this.dup().tap(function(dup) {
        return dup.sub_bang(pattern, replacement);
      });
    };

    String.prototype.sub_bang = function(pattern, replacement) {
      var pattern_lit, subbed;
      if (pattern === null) {
        throw R.TypeError["new"]();
      }
      pattern_lit = String.string_native(pattern);
      if (pattern_lit !== null) {
        pattern = new RegExp(R.Regexp.escape(pattern_lit));
      }
      if (!R.Regexp.isRegexp(pattern)) {
        throw R.TypeError["new"]();
      }
      if (pattern.global) {
        throw "String#sub: " + pattern + " has set the global flag 'g'. " + pattern + "g";
      }
      replacement = RCoerce.to_str_native(replacement);
      subbed = this.to_native().replace(pattern, replacement);
      return this.replace(subbed);
    };

    String.prototype.succ = function() {
      return this.dup().succ_bang();
    };

    String.prototype.succ_bang = function() {
      var c, carry, chars, codes, last_alnum, s, start;
      if (this.length === 0) {
        return this.replace("");
      } else {
        codes = (function() {
          var _j, _len1, _ref1, _results;
          _ref1 = this.to_native().split("");
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            c = _ref1[_j];
            _results.push(c.charCodeAt(0));
          }
          return _results;
        }).call(this);
        carry = null;
        last_alnum = 0;
        start = codes.length - 1;
        while (start >= 0) {
          s = codes[start];
          if (String.fromCharCode(s).match(/[a-zA-Z0-9]/) !== null) {
            carry = 0;
            if ((48 <= s && s < 57) || (97 <= s && s < 122) || (65 <= s && s < 90)) {
              codes[start] = codes[start] + 1;
            } else if (s === 57) {
              codes[start] = 48;
              carry = 49;
            } else if (s === 122) {
              codes[start] = carry = 97;
            } else if (s === 90) {
              codes[start] = carry = 65;
            }
            if (carry === 0) {
              break;
            }
            last_alnum = start;
          }
          start -= 1;
        }
        if (carry === null) {
          start = codes.length - 1;
          carry = 1;
          while (start >= 0) {
            s = codes[start];
            if (s >= 255) {
              codes[start] = 0;
            } else {
              codes[start] = codes[start] + 1;
              break;
            }
            start -= 1;
          }
        }
        chars = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = codes.length; _j < _len1; _j++) {
            c = codes[_j];
            _results.push(String.fromCharCode(c));
          }
          return _results;
        })();
        if (start < 0) {
          chars[last_alnum] = nativeString.fromCharCode(carry, codes[last_alnum]);
        }
        return this.replace(chars.join(""));
      }
    };

    String.prototype.next = String.prototype.succ;

    String.prototype.next_bang = String.prototype.succ_bang;

    String.prototype.swapcase = function() {
      return this.dup().tap(function(s) {
        return s.swapcase_bang();
      });
    };

    String.prototype.swapcase_bang = function() {
      if (!this.to_native().match(/[a-zA-Z]/)) {
        return null;
      }
      return this.replace(R(this.__char_natives__()).map(function(c) {
        if (c.match(/[a-z]/)) {
          return c.toUpperCase();
        } else if (c.match(/[A-Z]/)) {
          return c.toLowerCase();
        } else {
          return c;
        }
      }).join('').to_native());
    };

    String.prototype.to_a = function() {
      if (this.empty()) {
        return this.$Array([]);
      } else {
        return this.$Array([this]);
      }
    };

    String.prototype.valid_float = function() {
      var number_match;
      number_match = this.to_native().match(/^([\+\-]?\d[_\d]*)(\.\d*)?([eE][\+\-]?[\d_]+)?$/);
      return (number_match != null ? number_match[0] : void 0) != null;
    };

    String.prototype.to_f = function() {
      var number_match, number_string, _ref1;
      number_match = this.to_native().match(/^([\+\-]?[_\d\.]+)([Ee\+\-\d]+)?/);
      number_string = (_ref1 = number_match != null ? number_match[0] : void 0) != null ? _ref1 : "0.0";
      return this.$Float(Number(number_string.replace(/_/g, '')));
    };

    String.prototype.to_i = function(base) {
      var lit;
      if (base === void 0) {
        base = 10;
      }
      base = RCoerce.to_int_native(base);
      if (base < 0 || base > 36 || base === 1) {
        throw R.ArgumentError["new"]();
      }
      lit = this.strip().to_native();
      if (!lit.match(/^([\+\-]?)([^\+^\-_]+)/)) {
        return R(0);
      }
      lit = lit.replace(/_/g, '');
      return this.$Integer(parseInt(lit, base));
    };

    String.prototype.to_s = function() {
      return this;
    };

    String.prototype.to_str = String.prototype.to_s;

    String.prototype.tr = function(from_str, to_str) {
      return this.dup().tap(function(s) {
        return s.tr_bang(from_str, to_str);
      });
    };

    String.prototype.tr_bang = function(from_str, to_str) {
      throw R.NotImplementedError["new"]();
    };

    String.prototype.tr_s = function() {
      throw R.NotImplementedError["new"]();
    };

    String.upcase = function(str) {
      str = RCoerce.to_str_native(str);
      if (!str.match(/[a-z]/)) {
        return null;
      }
      return R(str.split('')).map(function(c) {
        if (c.match(/[a-z]/)) {
          return c.toUpperCase();
        } else {
          return c;
        }
      }).join('').to_native();
    };

    String.prototype.upcase = function() {
      return new RString(_str.upcase(this.__native__));
    };

    String.prototype.upcase_bang = function() {
      if (!this.__native__.match(/[a-z]/)) {
        return null;
      }
      return this.replace(_str.upcase(this.__native__));
    };

    String.prototype.upto = function(stop, exclusive, block) {
      var compare_fn, counter, stop_size;
      stop = RCoerce.to_str(stop);
      exclusive || (exclusive = false);
      if (block === void 0 && ((exclusive != null ? exclusive.call : void 0) != null)) {
        block = exclusive;
        exclusive = false;
      }
      if ((stop != null ? stop.is_string : void 0) == null) {
        throw R.TypeError["new"]();
      }
      if (!(block && (block.call != null))) {
        return R.Enumerator["new"](this, 'upto', stop, exclusive);
      }
      counter = this.dup();
      compare_fn = exclusive === false ? 'lteq' : 'lt';
      stop_size = stop.size();
      while (counter[compare_fn](stop) && !counter.size().gt(stop_size)) {
        block(counter);
        counter = counter.succ();
      }
      return this;
    };

    String.prototype.__char_natives__ = function() {
      return this.__native__.split('');
    };

    String.__add_default_aliases__(String.prototype);

    String.prototype.concat = String.prototype['<<'];

    String.prototype.asciiOnly = String.prototype.ascii_only;

    String.prototype.caseCompare = String.prototype.case_compare;

    String.prototype.eachChar = String.prototype.each_char;

    String.prototype.eachLine = String.prototype.each_line;

    String.prototype.endWith = String.prototype.end_with;

    String.prototype.startWith = String.prototype.start_with;

    String.prototype.trS = String.prototype.tr_s;

    return String;

  })(RubyJS.Object);

  RString = RubyJS.String;

  RubyJS.Regexp = (function(_super) {

    __extends(Regexp, _super);

    Regexp.prototype.IGNORECASE = 1;

    Regexp.prototype.EXTENDED = 2;

    Regexp.prototype.MULTILINE = 4;

    function Regexp(__native__) {
      this.__native__ = __native__;
    }

    Regexp["new"] = function(arg) {
      if (typeof arg === 'string') {
        arg = this.__compile__(arg);
      } else if (R.Regexp.isRegexp(arg)) {

      } else if (arg.is_regexp != null) {
        arg = arg.to_native();
      } else {
        arg = this.__compile__(RCoerce.to_str_native(arg));
      }
      return new R.Regexp(arg);
    };

    Regexp.compile = Regexp["new"];

    Regexp.try_convert = function(obj) {
      if (obj === null) {
        return null;
      } else if (this.isRegexp(obj)) {
        return new R.Regexp(obj);
      } else if (obj.to_regexp != null) {
        return obj.to_regexp();
      } else {
        return null;
      }
    };

    Regexp.isRegexp = function(obj) {
      return ((obj != null ? obj.is_regexp : void 0) != null) || _toString_.call(obj) === '[object RegExp]';
    };

    Regexp.prototype.is_regexp = function() {
      return true;
    };

    Regexp.prototype.to_native = function() {
      return this.__native__;
    };

    Regexp.prototype.inspect = function() {
      var src;
      src = this.source().to_native();
      return R("/" + src + "/" + (this.__flags__()));
    };

    Regexp.prototype['=='] = function(other) {
      other = R(other);
      return (other.to_native().source === this.to_native().source) && (other.casefold() === this.casefold());
    };

    Regexp.prototype['==='] = function(other) {
      return this.match(other) !== null;
    };

    Regexp.prototype['=~'] = function(str, offset) {
      var matches;
      matches = this.match(str, offset);
      return matches != null ? matches.begin(0) : void 0;
    };

    Regexp.prototype.casefold = function() {
      return this.to_native().ignoreCase;
    };

    Regexp.prototype.encoding = function() {
      throw R.NotSupportedError["new"]();
    };

    Regexp.prototype.eql = function() {
      return this['=='].apply(this, arguments);
    };

    Regexp.prototype.fixed_encoding = function() {
      throw R.NotSupportedError["new"]();
    };

    Regexp.prototype.hash = function() {
      throw R.NotSupportedError["new"]();
    };

    Regexp.prototype.match = function(str, offset) {
      var block, matches, opts, result;
      block = this.__extract_block(_slice_.call(arguments));
      if (str === null) {
        R['$~'] = null;
      } else {
        str = RCoerce.to_str_native(str);
        opts = {
          string: str,
          regexp: this
        };
        if (offset) {
          opts.offset = offset;
          str = str.slice(offset);
        }
        if (matches = str.match(this.to_native())) {
          R['$~'] = new R.MatchData(matches, opts);
        } else {
          R['$~'] = null;
        }
      }
      result = R['$~'];
      if (block) {
        if (result) {
          return block(result);
        } else {
          return new R.Array([]);
        }
      } else {
        return result;
      }
    };

    Regexp.prototype.quote = function(pattern) {
      return R.Regexp.quote(pattern);
    };

    Regexp.prototype.source = function() {
      return R(this.to_native().source);
    };

    Regexp.prototype.to_s = function() {
      return R("(" + (this.source()) + ")");
    };

    Regexp.last_match = function(n) {
      if (n && R['$~']) {
        return R['$~'][n];
      } else {
        return R['$~'];
      }
    };

    Regexp.quote = function(pattern) {
      return this.escape(pattern);
    };

    Regexp.escape = function(pattern) {
      pattern = pattern + '';
      return pattern.replace(/([.?*+^$[\](){}|-])/g, "\\$1").replace(/[\f]/g, '\\f').replace(/[\n]/g, '\\n').replace(/[\r]/g, '\\r').replace(/[\t]/g, '\\t').replace(/[\s]/g, '\\ ');
    };

    Regexp.union = function() {
      var arg, args, first_arg, sources;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        return R(/(?!)/);
      }
      first_arg = R(args[0]);
      if ((first_arg.is_array != null) && args.length === 1) {
        args = first_arg;
      }
      sources = (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
          arg = args[_j];
          arg = R(arg);
          if (arg.is_regexp != null) {
            _results.push(arg.to_s());
          } else {
            _results.push(RCoerce.to_str(arg));
          }
        }
        return _results;
      })();
      return new R.Regexp(new nativeRegExp(sources.join('|')));
    };

    Regexp.__compile__ = function(arg) {
      try {
        return new nativeRegExp(arg);
      } catch (error) {
        throw R.RegexpError["new"]();
      }
    };

    Regexp.prototype.__flags__ = function() {
      if (this.casefold()) {
        return 'i';
      } else {
        return '';
      }
    };

    Regexp.prototype.names = function() {
      throw R.NotSupportedError["new"]();
    };

    Regexp.prototype.named_captures = function() {
      throw R.NotSupportedError["new"]();
    };

    Regexp.prototype.options = function() {
      throw R.NotSupportedError["new"]();
    };

    Regexp.__add_default_aliases__(Regexp.prototype);

    Regexp.prototype.fixedEncoding = Regexp.prototype.fixed_encoding;

    return Regexp;

  })(RubyJS.Object);

  RubyJS.Numeric = (function(_super) {

    __extends(Numeric, _super);

    function Numeric() {
      return Numeric.__super__.constructor.apply(this, arguments);
    }

    Numeric.isNumeric = function(obj) {
      if (typeof obj === 'number') {
        return true;
      }
      if (typeof obj !== 'object') {
        return false;
      }
      if (obj === null) {
        return false;
      }
      return (obj.valueOf != null) && typeof obj.valueOf() === 'number';
    };

    Numeric.try_convert = function(obj) {
      if (!this.isNumeric(obj)) {
        return null;
      }
      return this["new"](obj);
    };

    Numeric["new"] = function(value) {
      if (value % 1 === 0) {
        return new R.Fixnum(value);
      } else {
        return new R.Float(value);
      }
    };

    Numeric.typecast = function(value) {
      if (value % 1 === 0) {
        return new R.Fixnum(value);
      } else {
        return new R.Float(value);
      }
    };

    Numeric.prototype.is_numeric = function() {
      return true;
    };

    Numeric.prototype['<=>'] = function(other) {
      if (this === other) {
        return 0;
      } else {
        return null;
      }
    };

    Numeric.prototype.abs = function() {
      if (this['<'](0)) {
        return this.uminus();
      } else {
        return this;
      }
    };

    Numeric.prototype.abs2 = function() {
      if (typeof this.nan === "function" ? this.nan() : void 0) {
        return this;
      }
      return this.abs()['**'](2);
    };

    Numeric.prototype.ceil = function() {
      return this.to_f().ceil();
    };

    Numeric.prototype.coerce = function(other) {
      if (!(other != null) || other === false) {
        throw RubyJS.TypeError["new"]();
      }
      other = R(other);
      if (other.is_string != null) {
        return this.$Array([this.$Float(other), this.to_f()]);
      } else if (other.constructor.prototype === this.constructor.prototype) {
        return this.$Array([other, this]);
      } else if (other.is_float != null) {
        return this.$Array([other, this.to_f()]);
      } else if (other.is_fixnum != null) {
        return this.$Array([other, this]);
      } else if (other.is_numeric != null) {
        return this.$Array([other.to_f(), this.to_f()]);
      } else {
        throw RubyJS.TypeError["new"]();
      }
    };

    Numeric.prototype.div = function(other) {
      other = this.box(other);
      if (other.to_int == null) {
        throw RubyJS.TypeError["new"]();
      }
      if (other.zero()) {
        throw new Error("ZeroDivisionError");
      }
      return this.divide(other).floor();
    };

    Numeric.prototype.divmod = function(other) {
      var modulus, quotient;
      quotient = this.div(other).floor();
      modulus = this.minus(quotient.multiply(other));
      return new R.Array([quotient, modulus]);
    };

    Numeric.prototype.eql = function(other) {
      other = this.box(other);
      if (!other) {
        return false;
      }
      if (this.__proto__ !== other.__proto__) {
        return false;
      }
      if (this['=='](other)) {
        return true;
      } else {
        return false;
      }
    };

    Numeric.prototype.inspect = function() {
      return new R.String("" + this.to_native());
    };

    Numeric.prototype.fdiv = function(other) {
      other = RCoerce.to_num_native(other);
      return this.to_f()['/'](other);
    };

    Numeric.prototype.floor = function() {
      return this.to_f().floor();
    };

    Numeric.prototype.magnitude = function() {
      return this.abs();
    };

    Numeric.prototype.modulo = function(other) {
      other = this.box(other);
      return this['-'](other['*'](this.div(other)));
    };

    Numeric.prototype.nonzero = function() {
      if (this.zero()) {
        return null;
      } else {
        return this;
      }
    };

    Numeric.prototype.quo = function(other) {
      var arr;
      other = this.box(other);
      if (other.zero()) {
        throw new Error("ZeroDivisionError");
      }
      arr = this.coerce(other);
      return this['/'](arr.first());
    };

    Numeric.prototype.rect = function() {
      if (arguments.length > 0) {
        throw R.ArgumentError["new"]();
      }
      return new R.Array([this, new R.Fixnum(0)]);
    };

    Numeric.prototype.rectangular = Numeric.prototype.rect;

    Numeric.prototype.remainder = function(other) {
      var mod;
      other = this.box(other);
      mod = this['%'](other);
      if (!mod['=='](0) && ((this['<'](0) && other['>'](0)) || (this['>'](0) && other['<'](0)))) {
        return mod['-'](other);
      } else {
        return mod;
      }
    };

    Numeric.prototype.round = function(n) {
      return this.to_f().round(n);
    };

    Numeric.prototype.step = function(limit, step, block) {
      if (step == null) {
        step = 1;
      }
      if ((block != null ? block.call : void 0) == null) {
        if ((step != null ? step.call : void 0) == null) {
          return this.to_enum('step', limit, step);
        }
      }
      _num.step(this.__native__, limit, step, block);
      return this;
    };

    Numeric.prototype.to_int = function() {
      return this.to_i();
    };

    Numeric.prototype.truncate = function() {
      return this.to_f().truncate();
    };

    Numeric.prototype.uminus = function() {
      return this.multiply(-1);
    };

    Numeric.prototype.zero = function() {
      return this['=='](0);
    };

    return Numeric;

  })(RubyJS.Object);

  RubyJS.Integer = (function(_super) {

    __extends(Integer, _super);

    function Integer() {
      return Integer.__super__.constructor.apply(this, arguments);
    }

    Integer["new"] = function(value) {
      return new R.Integer(value);
    };

    Integer.isInteger = function(obj) {
      return this.isNumeric(obj) && (obj % 1 === 0);
    };

    Integer.prototype.is_integer = function() {
      return true;
    };

    Integer.prototype.unbox = function() {
      return this.to_native();
    };

    Integer.prototype.chr = function() {
      return new R.String(String.fromCharCode(this.to_native()));
    };

    Integer.prototype.denominator = function() {
      return new R.Fixnum(1);
    };

    Integer.prototype.downto = function(stop, block) {
      try {
        stop = RCoerce.to_num_native(stop);
      } catch (err) {
        throw R.ArgumentError["new"]();
      }
      if ((block != null ? block.call : void 0) == null) {
        return R.Enumerator["new"](this, 'downto', stop);
      }
      _num.downto(this.__native__, stop, block);
      return this;
    };

    Integer.prototype.even = function() {
      return this.to_native() % 2 === 0;
    };

    Integer.prototype.gcd = function(other) {
      var n;
      other = R(other);
      this.__ensure_args_length(arguments, 1);
      this.__ensure_integer__(other);
      n = _num.gcd(this.__native__, other.to_native());
      return new R.Fixnum(n);
    };

    Integer.prototype.gcdlcm = function(other) {
      other = this.box(other);
      this.__ensure_args_length(arguments, 1);
      this.__ensure_integer__(other);
      return new R.Array([this.gcd(other), this.lcm(other)]);
    };

    Integer.prototype.lcm = function(other) {
      var lcm;
      other = R(other);
      this.__ensure_args_length(arguments, 1);
      this.__ensure_integer__(other);
      lcm = new R.Fixnum(this.to_native() * other.to_native() / this.gcd(other));
      return lcm.numerator();
    };

    Integer.prototype.numerator = function() {
      return new R.Fixnum(_num.numerator(this.__native__));
    };

    Integer.prototype.odd = function() {
      return !this.even();
    };

    Integer.prototype.ord = function() {
      return this;
    };

    Integer.prototype.next = function() {
      return this.plus(1);
    };

    Integer.prototype.pred = function() {
      return this.minus(1);
    };

    Integer.prototype.round = function(n) {
      if (n === void 0) {
        return this;
      }
      n = RCoerce.to_int_native(n);
      if (n > 0) {
        return this.to_f();
      } else if (n === 0) {
        return this;
      } else {
        return new R.Fixnum(_num.round(this.__native__, n));
      }
    };

    Integer.prototype.succ = Integer.prototype.next;

    Integer.prototype.times = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('times');
      }
      return new R.Fixnum(_num.times(this.__native__, block));
    };

    Integer.prototype.to_i = function() {
      return this;
    };

    Integer.prototype.upto = function(stop, block) {
      try {
        stop = RCoerce.to_num_native(stop);
      } catch (err) {
        throw R.ArgumentError["new"]();
      }
      if ((block != null ? block.call : void 0) == null) {
        return R.Enumerator["new"](this, 'upto', stop);
      }
      return _num.upto(this.__native__, stop, block);
    };

    Integer.prototype.toString = function() {
      return "" + (this.to_native());
    };

    Integer.prototype.__ensure_integer__ = function(other) {
      if ((other != null ? other.is_integer : void 0) == null) {
        throw RubyJS.TypeError["new"]();
      }
    };

    Integer.prototype.to_int = Integer.prototype.to_i;

    Integer.prototype.truncate = Integer.prototype.to_i;

    return Integer;

  })(RubyJS.Numeric);

  RubyJS.Fixnum = (function(_super) {

    __extends(Fixnum, _super);

    Fixnum.include(R.Comparable);

    function Fixnum(__native__) {
      this.__native__ = __native__;
    }

    Fixnum["new"] = function(val) {
      return new R.Fixnum(val);
    };

    Fixnum.try_convert = function(obj) {
      obj = R(obj);
      if (obj.to_int == null) {
        throw R.TypeError["new"]();
      }
      return obj;
    };

    Fixnum.__cache_fixnums__ = function(from, to) {
      var i, _j, _results;
      if (from == null) {
        from = -1;
      }
      if (to == null) {
        to = 256;
      }
      _results = [];
      for (i = _j = from; from <= to ? _j <= to : _j >= to; i = from <= to ? ++_j : --_j) {
        _results.push(this.__memoized_fixnums__[i] = new R.Fixnum(i));
      }
      return _results;
    };

    Fixnum.prototype.is_fixnum = function() {
      return true;
    };

    Fixnum.prototype.to_native = function() {
      return this.__native__;
    };

    Fixnum.prototype.valueOf = Fixnum.prototype.to_native;

    Fixnum.prototype.unbox = Fixnum.prototype.to_native;

    Fixnum.prototype.dup = function() {
      return Fixnum["new"](this.to_native());
    };

    Fixnum.prototype['=='] = function(other) {
      if (!(R(other).is_fixnum != null)) {
        return R(other)['=='](this);
      } else {
        return this['<=>'](other) === 0;
      }
    };

    Fixnum.prototype['==='] = Fixnum.prototype['=='];

    Fixnum.prototype['<=>'] = function(other) {
      if (typeof other !== 'number') {
        other = R(other);
        if (other.is_numeric == null) {
          return null;
        }
        if (other.to_int == null) {
          throw R.TypeError["new"]();
        }
        other = other.to_native();
      }
      if (this.to_native() < other) {
        return -1;
      } else if (this.to_native() > other) {
        return 1;
      } else {
        return 0;
      }
    };

    Fixnum.prototype['+'] = function(other) {
      return R.Numeric.typecast(this.to_native() + RCoerce.to_num_native(other));
    };

    Fixnum.prototype['-'] = function(other) {
      return R.Numeric.typecast(this.to_native() - RCoerce.to_num_native(other));
    };

    Fixnum.prototype['/'] = function(other) {
      var val;
      other = Fixnum.try_convert(other);
      if ((other.is_float != null) && other.zero()) {
        if (this.to_native() > 0) {
          return R('Infinity');
        } else {
          return R('-Infinity');
        }
      } else if (+other === 0) {
        throw R.ZeroDivisionError["new"]();
      } else {
        val = R.Numeric.typecast(this.to_native() / other.to_native());
        if (other.is_float != null) {
          return val;
        } else {
          return val.floor();
        }
      }
    };

    Fixnum.prototype['*'] = function(other) {
      return R.Numeric.typecast(this.to_native() * RCoerce.to_num_native(other));
    };

    Fixnum.prototype['**'] = function(other) {
      var val;
      other = this.box(other);
      val = this.box(Math.pow(this.to_native(), other.to_native()));
      if (other.is_float != null) {
        return val.to_f();
      } else {
        return val.to_i();
      }
    };

    Fixnum.prototype['%'] = function(other) {
      var division, fixnum, is_float, val;
      is_float = this.box(other).is_float != null;
      fixnum = Fixnum.try_convert(other);
      if (fixnum.zero()) {
        throw R.ZeroDivisionError["new"]();
      }
      fixnum = fixnum.to_int();
      division = this['/'](fixnum);
      val = this.minus(division.multiply(fixnum));
      if (is_float) {
        return val.to_f();
      } else {
        return val.to_i();
      }
    };

    Fixnum.prototype.fdiv = function(other) {
      other = R(other);
      if (other.is_numeric == null) {
        throw R.TypeError["new"]();
      }
      this.__ensure_args_length(arguments, 1);
      return this.to_f().divide(other.to_f());
    };

    Fixnum.prototype.object_id = function() {
      return this.__native__ * 2 + 1;
    };

    Fixnum.prototype.to_f = function() {
      return this.$Float(this.to_native());
    };

    Fixnum.prototype.to_s = function(base) {
      if (base == null) {
        base = 10;
      }
      base = this.box(base);
      if (base.lt(2) || base.gt(36)) {
        throw R.ArgumentError["new"]();
      }
      return this.box("" + (this.to_native().toString(base.to_native())));
    };

    Fixnum.__add_default_aliases__(Fixnum.prototype);

    return Fixnum;

  })(RubyJS.Integer);

  RubyJS.Float = (function(_super) {

    __extends(Float, _super);

    Float.include(R.Comparable);

    Float.INFINITY = 1.0 / 0.0;

    Float.NAN = 0.0 / 0.0;

    Float.DIG = 15;

    Float.EPSILON = 0.0000000000000002220446049250313080847263336181640625;

    Float.MANT_DIG = 53;

    Float.MAX_10_EXP = 308;

    Float.MIN_10_EXP = -307;

    Float.MAX_EXP = 1024;

    Float.MIN_EXP = -1021;

    Float.MAX = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;

    Float.MANT_DIG = 53;

    Float.MIN = 2.225073858507201383090232717332404064219215980462331830553327416887204434813918195854283159012511020564067339731035811005152434161553460108856012385377718821130777993532002330479610147442583636071921565046942503734208375250806650616658158948720491179968591639648500635908770118304874799780887753749949451580451605050915399856582470818645113537935804992115981085766051992433352114352390148795699609591288891602992641511063466313393663477586513029371762047325631781485664350872122828637642044846811407613911477062801689853244110024161447421618567166150540154285084716752901903161322778896729707373123334086988983175067838846926092773977972858659654941091369095406136467568702398678315290680984617210924625396728515625e-308;

    Float.RADIX = 2;

    Float["new"] = function(f) {
      return new R.Float(f);
    };

    function Float(__native__) {
      this.__native__ = __native__;
    }

    Float.prototype.is_float = function() {
      return true;
    };

    Float.isFloat = function(obj) {
      return R.Numeric.isNumeric(obj) && !R.Integer.isInteger(obj);
    };

    Float.prototype['<=>'] = function(other) {
      if (!(this.box(other).is_numeric != null)) {
        return null;
      }
      other = RCoerce.to_num_native(other);
      if (this.to_native() === other) {
        return 0;
      }
      if (this.to_native() < other) {
        return -1;
      }
      if (this.to_native() > other) {
        return 1;
      }
    };

    Float.prototype['=='] = function(other) {
      other = this.box(other);
      return this.to_native() === other.to_native();
    };

    Float.prototype['+'] = function(other) {
      return new Float(this.to_native() + RCoerce.to_num_native(other));
    };

    Float.prototype['-'] = function(other) {
      return new Float(this.to_native() - RCoerce.to_num_native(other));
    };

    Float.prototype['*'] = function(other) {
      return new Float(this.to_native() * RCoerce.to_num_native(other));
    };

    Float.prototype['/'] = function(other) {
      return new Float(this.to_native() / RCoerce.to_num_native(other));
    };

    Float.prototype['**'] = function(other) {
      return new Float(Math.pow(this.to_native(), RCoerce.to_num_native(other)) + 0);
    };

    Float.prototype['%'] = function(other) {
      var div, inf, val;
      other = this.box(other);
      if (other.equals(0)) {
        throw new Error("ZeroDivisionError");
      }
      if (!this.finite()) {
        return this.box(Float.NAN).to_f();
      }
      if (inf = typeof other.infinite === "function" ? other.infinite() : void 0) {
        if (inf === -1) {
          return other;
        }
        if (inf === 1) {
          return this;
        }
      }
      div = this['/'](other).floor();
      val = this.to_native() - (div.to_native() * other.to_native());
      return new Float(val);
    };

    Float.prototype.arg = function() {
      if (this.nan()) {
        return this;
      } else if (this.__native__ < 0.0) {
        return new R.Float(Math.PI);
      } else {
        return new R.Float(0);
      }
    };

    Float.prototype.ceil = function() {
      return new R.Fixnum(Math.ceil(this.to_native()));
    };

    Float.prototype.inspect = function() {
      return this.to_s();
    };

    Float.prototype.dup = function() {
      return Float["new"](this.to_native());
    };

    Float.prototype.eql = function(other) {
      other = this.box(other);
      if (other.is_float == null) {
        return false;
      }
      return this.equals(other);
    };

    Float.prototype.finite = function() {
      return !(this.infinite() || this.nan());
    };

    Float.prototype.infinite = function() {
      if (this.to_native() === Float.INFINITY) {
        return 1;
      } else if (this.to_native() === -Float.INFINITY) {
        return -1;
      } else {
        return null;
      }
    };

    Float.prototype.nan = function() {
      return isNaN(this.to_native());
    };

    Float.prototype.to_f = function() {
      return this.dup();
    };

    Float.prototype.to_i = function() {
      if (this.to_native() < 0) {
        return this.ceil();
      } else {
        return this.floor();
      }
    };

    Float.prototype.floor = function() {
      return new R.Fixnum(Math.floor(this.__native__));
    };

    Float.prototype.quo = function(other) {
      this.__ensure_args_length(arguments, 1);
      other = this.box(other);
      return this.divide(other);
    };

    Float.prototype.round = function(n) {
      var multiplier, rounded;
      if (n == null) {
        n = 0;
      }
      n = RCoerce.to_int_native(n);
      if (this.infinite()) {
        throw new TypeError("FloatDomainError");
      }
      if (this.nan()) {
        throw new TypeError("RangeError");
      }
      if (n === 0) {
        return new R.Fixnum(Math.round(this.to_native()));
      }
      multiplier = Math.pow(10, n);
      rounded = Math.round(this.to_native() * multiplier) / multiplier;
      if (n > 0) {
        return new R.Float(rounded);
      } else {
        return new R.Fixnum(rounded);
      }
    };

    Float.prototype.to_s = function() {
      var inf, v;
      v = "" + this.to_native();
      if (this.nan()) {
        v = "NaN";
      } else if (inf = this.infinite()) {
        if (inf === -1) {
          v = "-Infinity";
        }
        if (inf === 1) {
          v = "Infinity";
        }
      } else if (v.indexOf('.') < 0) {
        v += ".0";
      }
      return this.$String(v);
    };

    Float.prototype.toString = function() {
      return this.to_native().toString();
    };

    Float.prototype.valueOf = function() {
      return this.__native__;
    };

    Float.prototype.to_native = function() {
      return this.__native__;
    };

    Float.prototype.unbox = Float.prototype.to_native;

    Float.prototype.angle = Float.prototype.arg;

    Float.prototype.fdiv = Float.prototype.quo;

    Float.prototype.magnitude = Float.prototype.abs;

    Float.prototype.phase = Float.prototype.arg;

    Float.prototype.to_int = Float.prototype.to_i;

    Float.prototype.truncate = Float.prototype.to_i;

    Float.prototype['==='] = Float.prototype['=='];

    Float.__add_default_aliases__(Float.prototype);

    return Float;

  })(RubyJS.Numeric);

  /*
  
  new RubyJS.Time(new Date(), 3600)
  
  JS Date objects have no support for timezones. R.Time emulates timezones using
  a second fake object that is offset by the user defined utc_offset.
  
  
  @example If local timezone is ICT (+07:00)
  
      t = R.Time.new(2012,12,24,12,0,0, "+01:00")
      t.__native__
      # => Mon Dec 24 2012 18:00:00 GMT+0700 (ICT)
      # t.__native__ has the correct timestamp for the local time.
      #              2012-12-24 12:00 (CET) - "+01:00 (CET)"
      #              2012-12-24 11:00 (UCT) + "+07:00 (ICT)"
      #              2012-12-24 18:00 (ICT)
      #
      t._tzdate
      # => Mon Dec 24 2012 12:00:00 GMT+0700 (ICT)
      #
      # t._tzdate holds the wrong timestamp but is useful to work with native JS
      # methods.
      #
      t.hour()      # => 12 (internally uses _tzdate.getHours())
  */


  RubyJS.Time = (function(_super) {

    __extends(Time, _super);

    Time.include(R.Comparable);

    Time.LOCALE = {
      'DAYS': ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
      'DAYS_SHORT': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      'MONTHS': [null, 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
      'MONTHS_SHORT': [null, 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      'AM': 'AM',
      'PM': 'PM',
      'AM_LOW': 'am',
      'PM_LOW': 'pm'
    };

    Time.TIME_ZONES = {
      'UTC': 0,
      'UT': 0,
      'GMT': 0,
      'EST': -5,
      'EDT': -4,
      'CST': -6,
      'CDT': -5,
      'MST': -7,
      'MDT': -6,
      'PST': -8,
      'PDT': -7
    };

    function Time(__native__, utc_offset) {
      this.__native__ = __native__;
      if (utc_offset != null) {
        this.__utc_offset__ = utc_offset;
        this._tzdate = R.Time._offset_to_local(this.__native__, this.__utc_offset__);
      } else {
        this._tzdate = this.__native__;
        this.__utc_offset__ = R.Time._local_timezone();
      }
    }

    Time.now = function() {
      return R.Time["new"]();
    };

    Time["new"] = function(year, month, day, hour, min, sec, utc_offset) {
      var date;
      if (arguments.length === 0) {
        return new R.Time(new Date());
      }
      if (year === null) {
        throw R.TypeError["new"]();
      }
      month || (month = 1);
      day || (day = 1);
      hour || (hour = 0);
      min || (min = 0);
      sec || (sec = 0);
      if (month > 12 || day > 31 || hour > 24 || min > 59 || sec > 59 || month < 0 || day < 0 || hour < 0 || min < 0 || sec < 0) {
        throw R.ArgumentError["new"]();
      }
      if (utc_offset != null) {
        utc_offset = this._parse_utc_offset(utc_offset);
        date = new Date(year, month - 1, day, hour, min, sec);
        date = this._local_to_offset(date, utc_offset);
      } else {
        date = new Date(year, month - 1, day, hour, min, sec);
        utc_offset = this._local_timezone();
      }
      return new R.Time(date, utc_offset);
    };

    Time._local_to_offset = function(date, utc_offset) {
      date = date.valueOf() + R.Time._local_timezone() * 1000;
      date = date - utc_offset * 1000;
      return new Date(date);
    };

    Time._offset_to_local = function(date, utc_offset) {
      date = date.valueOf() - R.Time._local_timezone() * 1000;
      date += utc_offset * 1000;
      return new Date(date);
    };

    Time._parse_utc_offset = function(offset) {
      var hour, mins, secs, sign, _ref1;
      if (offset == null) {
        return null;
      }
      offset = R(offset);
      secs = null;
      if ((offset.is_string != null) || (offset.to_str != null)) {
        offset = offset.to_str().to_native();
        if (!offset.match(/[\+|-]\d\d:\d\d/)) {
          throw R.ArgumentError["new"]();
        }
        sign = offset[0] === '-' ? -1 : 1;
        _ref1 = offset.split(':'), hour = _ref1[0], mins = _ref1[1];
        mins = parseInt(mins);
        hour = parseInt(hour.slice(1));
        secs = sign * (hour * 60 + mins) * 60;
      } else if ((offset.is_fixnum != null) || (offset.to_int != null)) {
        secs = offset.to_int();
        if (Math.abs(secs) >= 86400) {
          throw R.ArgumentError["new"]();
        }
      } else {
        throw R.TypeError["new"]();
      }
      return Math.floor(secs);
    };

    Time.at = function(seconds, microseconds) {
      var msecs, secs;
      if (seconds === null) {
        throw R.TypeError["new"]();
      }
      if (microseconds !== void 0) {
        if (microseconds === null || (R(microseconds).is_string != null)) {
          throw R.TypeError["new"]();
        } else {
          microseconds = RCoerce.to_num_native(microseconds);
        }
      } else {
        microseconds = 0;
      }
      seconds = R(seconds);
      if (seconds.is_time != null) {
        secs = seconds.to_i();
        msecs = secs * 1000 + microseconds / 1000;
        return new R.Time(new Date(msecs), time.utc_offset());
      } else if (seconds.is_numeric != null) {
        secs = seconds.valueOf();
        msecs = secs * 1000 + microseconds / 1000;
        return new R.Time(new Date(msecs), this._local_timezone());
      } else {
        throw R.TypeError["new"]();
      }
    };

    Time.local = function(year, month, day, hour, min, sec) {
      return R.Time["new"](year, month, day, hour, min, sec, this._local_timezone());
    };

    Time.utc = function(year, month, day, hour, min, sec) {
      var date;
      date = new Date(Date.UTC(year, (month || 1) - 1, day || 1, hour || 0, min || 0, sec || 0));
      return new R.Time(date, 0);
    };

    Time.gm = Time.utc;

    Time.now = function() {
      return R.Time["new"]();
    };

    Time._local_timezone = function() {
      return new Date().getTimezoneOffset() * -60;
    };

    Time.prototype.is_time = function() {
      return true;
    };

    Time.prototype['<=>'] = function(other) {
      var secs;
      secs = this.valueOf();
      other = other.valueOf();
      if (secs < other) {
        return -1;
      } else if (secs > other) {
        return 1;
      } else {
        return 0;
      }
    };

    Time.prototype.cmp = Time.prototype['<=>'];

    Time.prototype['=='] = function(other) {
      other = R(other);
      if (other.is_time == null) {
        return false;
      }
      return this['<=>'](other) === 0;
    };

    Time.prototype['-'] = function(other) {
      var tmstmp;
      if (other == null) {
        throw R.TypeError["new"]();
      }
      other = R(other);
      if (other.is_numeric != null) {
        tmstmp = this.valueOf() - (other.valueOf() * 1000);
        return new R.Time(new Date(tmstmp), this.__utc_offset__);
      } else if (other.is_time != null) {
        return new R.Float((this.valueOf() - other.valueOf()) / 1000);
      } else {
        throw R.TypeError["new"]();
      }
    };

    Time.prototype['+'] = function(other) {
      var tmstmp, tpcast;
      if (other == null) {
        throw R.TypeError["new"]();
      }
      tpcast = R(other);
      if (typeof other !== 'number' || !(tpcast.is_numeric != null)) {
        if (!(tpcast.is_time != null) && (other.to_f != null)) {
          other = other.to_f();
        } else {
          throw R.TypeError["new"]();
        }
      }
      tmstmp = this.valueOf() + other.valueOf() * 1000;
      return new R.Time(new Date(tmstmp), this.__utc_offset__);
    };

    Time.prototype.asctime = function() {
      return this.strftime("%a %b %e %H:%M:%S %Y");
    };

    Time.prototype.ctime = Time.prototype.asctime;

    Time.prototype.dup = function() {
      return new R.Time(new Date(this.__native__), this.__utc_offset__);
    };

    Time.prototype.year = function() {
      return new R.Fixnum(this._tzdate.getFullYear());
    };

    Time.prototype.month = function() {
      return new R.Fixnum(this._tzdate.getMonth() + 1);
    };

    Time.prototype.mon = Time.prototype.month;

    Time.prototype.monday = function() {
      return this.wday().to_native() === 1;
    };

    Time.prototype.tuesday = function() {
      return this.wday().to_native() === 2;
    };

    Time.prototype.wednesday = function() {
      return this.wday().to_native() === 3;
    };

    Time.prototype.thursday = function() {
      return this.wday().to_native() === 4;
    };

    Time.prototype.friday = function() {
      return this.wday().to_native() === 5;
    };

    Time.prototype.saturday = function() {
      return this.wday().to_native() === 6;
    };

    Time.prototype.sunday = function() {
      return this.wday().to_native() === 0;
    };

    Time.prototype.day = function() {
      return new R.Fixnum(this._tzdate.getDate());
    };

    Time.prototype.mday = Time.prototype.day;

    Time.prototype.getgm = function() {
      return new R.Time(this.__native__, 0);
    };

    Time.prototype.getutc = Time.prototype.getgm;

    Time.prototype.gmt = function() {
      return this.__utc_offset__ === 0;
    };

    Time.prototype.is_utc = Time.prototype.gmt;

    Time.prototype.gmt_offset = function() {
      return new R.Fixnum(this.__utc_offset__);
    };

    Time.prototype.gmtoff = Time.prototype.gmt_offset;

    Time.prototype.utc_offset = Time.prototype.gmt_offset;

    Time.prototype.gmtime = function() {
      this._tzdate = new Date(this.__native__ - this.__utc_offset__ * 1000);
      this.__utc_offset__ = 0;
      return this;
    };

    Time.prototype.hour = function() {
      return new R.Fixnum(this._tzdate.getHours());
    };

    Time.prototype.hour12 = function() {
      return new R.Fixnum(this._tzdate.getHours() % 12);
    };

    Time.prototype.inspect = function() {
      if (this.gmt()) {
        return this.strftime('%Y-%m-%d %H:%M:%S UTC');
      } else {
        return this.strftime('%Y-%m-%d %H:%M:%S %z');
      }
    };

    Time.prototype.min = function() {
      return new R.Fixnum(this._tzdate.getMinutes());
    };

    Time.prototype.sec = function() {
      return new R.Fixnum(this._tzdate.getSeconds());
    };

    Time.prototype.strftime = function(format) {
      var fill, locale, out, self;
      locale = R.Time.LOCALE;
      fill = this._rjust;
      self = this;
      out = format.replace(/%(.)/g, function(_, flag) {
        var day, jtime;
        switch (flag) {
          case 'a':
            return locale.DAYS_SHORT[self.wday()];
          case 'A':
            return locale.DAYS[self.wday()];
          case 'b':
            return locale.MONTHS_SHORT[self.month()];
          case 'B':
            return locale.MONTHS[self.month()];
          case 'C':
            return self.year() % 100;
          case 'd':
            return fill(self.day());
          case 'D':
            return self.strftime('%m/%d/%y');
          case 'e':
            return fill(self.day(), ' ');
          case 'F':
            return self.strftime('%Y-%m-%d');
          case 'h':
            return locale.MONTHS_SHORT[self.month()];
          case 'H':
            return fill(self.hour());
          case 'I':
            return fill(self.hour12());
          case 'j':
            jtime = new Date(self.year(), 0, 1).getTime();
            return Math.ceil((self._tzdate.getTime() - jtime) / (1000 * 60 * 60 * 24));
          case 'k':
            return self.hour().to_s().rjust(2, ' ');
          case 'l':
            return fill(self.hour12(), ' ');
          case 'm':
            return fill(self.month());
          case 'M':
            return fill(self.min());
          case 'n':
            return "\n";
          case 'N':
            throw R.NotImplementedError["new"]();
            break;
          case 'p':
            if (self.hour() < 12) {
              return locale.AM;
            } else {
              return locale.PM;
            }
            break;
          case 'P':
            if (self.hour() < 12) {
              return locale.AM_LOW;
            } else {
              return locale.PM_LOW;
            }
            break;
          case 'r':
            return self.strftime('%I:%M:%S %p');
          case 'R':
            return self.strftime('%H:%M');
          case 'S':
            return fill(self.sec());
          case 't':
            return "\t";
          case 'T':
            return self.strftime('%H:%M:%S');
          case 'u':
            day = self.wday().to_native();
            if (day === 0) {
              return 7;
            } else {
              return day;
            }
            break;
          case 'v':
            return self.strftime('%e-%b-%Y');
          case 'w':
            return self.wday();
          case 'y':
            return self.year().to_s().slice(-2, 2);
          case 'Y':
            return self.year();
          case 'x':
            return self.strftime('%m/%d/%y');
          case 'X':
            return self.strftime('%H:%M:%S');
          case 'z':
            return self._offset_str();
          case 'Z':
            return self.zone();
          default:
            return flag;
        }
      });
      return new R.String(out);
    };

    Time.prototype.succ = function() {
      return R.Time.at(this.to_i().succ());
    };

    Time.prototype.to_i = function() {
      return R(this.__native__.getTime() / 1000).to_i();
    };

    Time.prototype.to_f = function() {
      return new R.Float(this.to_i() + ((this.valueOf() % 1000) / 1000));
    };

    Time.prototype.to_s = Time.prototype.inspect;

    Time.prototype.__tz_delta__ = function() {
      return this.__utc_offset__ + R.Time._local_timezone();
    };

    Time.prototype.__utc_delta__ = function() {
      return this.gmt_offset() + R.Time._local_timezone();
    };

    Time.prototype.tv_sec = Time.prototype.to_i;

    Time.prototype.tv_usec = function() {
      return new R.Fixnum((this._tzdate.valueOf() % 1000) * 1000);
    };

    Time.prototype.usec = Time.prototype.tv_usec;

    Time.prototype.wday = function() {
      return new R.Fixnum(this._tzdate.getDay());
    };

    Time.prototype.yday = function() {
      var secs, ytd;
      ytd = new Date(this.year(), 0, 0);
      secs = this.__native__.getTime() + this.gmt_offset() * 1000 - ytd.getTime();
      return R(Math.floor(secs / 86400000));
    };

    Time.prototype.valueOf = function() {
      return this.__native__.valueOf();
    };

    Time.prototype.zone = function() {
      if (this.gmt()) {
        return new R.String('UTC');
      } else {
        throw R.NotImplementedError["new"]("Time#zone only supports UTC/GMT");
      }
    };

    Time.prototype._rjust = function(fixnum, str) {
      if (str == null) {
        str = '0';
      }
      return new R.String(fixnum + "").rjust(2, str);
    };

    Time.prototype._offset_str = function() {
      var hour, mins, sign;
      mins = this.gmt_offset() / 60;
      if (mins === 0) {
        return '+0000';
      }
      sign = mins > 0 ? '+' : '-';
      mins = Math.abs(mins);
      hour = this._rjust(Math.ceil(mins / 60));
      mins = this._rjust(mins % 60);
      return sign + hour + mins;
    };

    Time.__add_default_aliases__(Time.prototype);

    Time.prototype.eql = Time.prototype['=='];

    return Time;

  })(RubyJS.Object);

  RubyJS.pollute_global();

}).call(this);
